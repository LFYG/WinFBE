<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang xml:lang>
<head>
  <meta http-equiv='X-UA-Compatible' content='IE=edge' />
  <meta http-equiv='MSThemeCompatible' content='Yes'>

  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>CVAR Class</title>
  <style type="text/css">
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
  <style type="text/css">@font-face {font-family: octicons-link;src: url(data:font/woff;charset=utf-8;base64,d09GRgABAAAAAAZwABAAAAAACFQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABEU0lHAAAGaAAAAAgAAAAIAAAAAUdTVUIAAAZcAAAACgAAAAoAAQAAT1MvMgAAAyQAAABJAAAAYFYEU3RjbWFwAAADcAAAAEUAAACAAJThvmN2dCAAAATkAAAABAAAAAQAAAAAZnBnbQAAA7gAAACyAAABCUM+8IhnYXNwAAAGTAAAABAAAAAQABoAI2dseWYAAAFsAAABPAAAAZwcEq9taGVhZAAAAsgAAAA0AAAANgh4a91oaGVhAAADCAAAABoAAAAkCA8DRGhtdHgAAAL8AAAADAAAAAwGAACfbG9jYQAAAsAAAAAIAAAACABiATBtYXhwAAACqAAAABgAAAAgAA8ASm5hbWUAAAToAAABQgAAAlXu73sOcG9zdAAABiwAAAAeAAAAME3QpOBwcmVwAAAEbAAAAHYAAAB/aFGpk3jaTY6xa8JAGMW/O62BDi0tJLYQincXEypYIiGJjSgHniQ6umTsUEyLm5BV6NDBP8Tpts6F0v+k/0an2i+itHDw3v2+9+DBKTzsJNnWJNTgHEy4BgG3EMI9DCEDOGEXzDADU5hBKMIgNPZqoD3SilVaXZCER3/I7AtxEJLtzzuZfI+VVkprxTlXShWKb3TBecG11rwoNlmmn1P2WYcJczl32etSpKnziC7lQyWe1smVPy/Lt7Kc+0vWY/gAgIIEqAN9we0pwKXreiMasxvabDQMM4riO+qxM2ogwDGOZTXxwxDiycQIcoYFBLj5K3EIaSctAq2kTYiw+ymhce7vwM9jSqO8JyVd5RH9gyTt2+J/yUmYlIR0s04n6+7Vm1ozezUeLEaUjhaDSuXHwVRgvLJn1tQ7xiuVv/ocTRF42mNgZGBgYGbwZOBiAAFGJBIMAAizAFoAAABiAGIAznjaY2BkYGAA4in8zwXi+W2+MjCzMIDApSwvXzC97Z4Ig8N/BxYGZgcgl52BCSQKAA3jCV8CAABfAAAAAAQAAEB42mNgZGBg4f3vACQZQABIMjKgAmYAKEgBXgAAeNpjYGY6wTiBgZWBg2kmUxoDA4MPhGZMYzBi1AHygVLYQUCaawqDA4PChxhmh/8ODDEsvAwHgMKMIDnGL0x7gJQCAwMAJd4MFwAAAHjaY2BgYGaA4DAGRgYQkAHyGMF8NgYrIM3JIAGVYYDT+AEjAwuDFpBmA9KMDEwMCh9i/v8H8sH0/4dQc1iAmAkALaUKLgAAAHjaTY9LDsIgEIbtgqHUPpDi3gPoBVyRTmTddOmqTXThEXqrob2gQ1FjwpDvfwCBdmdXC5AVKFu3e5MfNFJ29KTQT48Ob9/lqYwOGZxeUelN2U2R6+cArgtCJpauW7UQBqnFkUsjAY/kOU1cP+DAgvxwn1chZDwUbd6CFimGXwzwF6tPbFIcjEl+vvmM/byA48e6tWrKArm4ZJlCbdsrxksL1AwWn/yBSJKpYbq8AXaaTb8AAHja28jAwOC00ZrBeQNDQOWO//sdBBgYGRiYWYAEELEwMTE4uzo5Zzo5b2BxdnFOcALxNjA6b2ByTswC8jYwg0VlNuoCTWAMqNzMzsoK1rEhNqByEyerg5PMJlYuVueETKcd/89uBpnpvIEVomeHLoMsAAe1Id4AAAAAAAB42oWQT07CQBTGv0JBhagk7HQzKxca2sJCE1hDt4QF+9JOS0nbaaYDCQfwCJ7Au3AHj+LO13FMmm6cl7785vven0kBjHCBhfpYuNa5Ph1c0e2Xu3jEvWG7UdPDLZ4N92nOm+EBXuAbHmIMSRMs+4aUEd4Nd3CHD8NdvOLTsA2GL8M9PODbcL+hD7C1xoaHeLJSEao0FEW14ckxC+TU8TxvsY6X0eLPmRhry2WVioLpkrbp84LLQPGI7c6sOiUzpWIWS5GzlSgUzzLBSikOPFTOXqly7rqx0Z1Q5BAIoZBSFihQYQOOBEdkCOgXTOHA07HAGjGWiIjaPZNW13/+lm6S9FT7rLHFJ6fQbkATOG1j2OFMucKJJsxIVfQORl+9Jyda6Sl1dUYhSCm1dyClfoeDve4qMYdLEbfqHf3O/AdDumsjAAB42mNgYoAAZQYjBmyAGYQZmdhL8zLdDEydARfoAqIAAAABAAMABwAKABMAB///AA8AAQAAAAAAAAAAAAAAAAABAAAAAA==) format('woff');}body {-webkit-text-size-adjust: 100%;text-size-adjust: 100%;color: #333;font-family: "Helvetica Neue", Helvetica, "Segoe UI", Arial, freesans, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol";font-size: 16px;line-height: 1.6;word-wrap: break-word;max-width: 99%;box-sizing: border-box;padding: 20px 5px 8rem 5px; margin-left: auto;margin-right: auto;}body a {background-color: transparent;}body a:active,body a:hover {outline: 0;}body strong {font-weight: bold;}body h1 {font-size: 2em;margin: 0.67em 0;}body img {border: 0;}body hr {box-sizing: content-box;height: 0;}body pre {overflow: auto;}body code,body kbd,body pre {font-family: monospace, monospace;font-size: 1em;}body input {color: inherit;font: inherit;margin: 0;}body html input[disabled] {cursor: default;}body input {line-height: normal;}body input[type="checkbox"] {box-sizing: border-box;padding: 0;}body table {border-collapse: collapse;border-spacing: 0;}body td,body th {padding: 0;}body * {box-sizing: border-box;}body input {font: 13px / 1.4 Helvetica, arial, nimbussansl, liberationsans, freesans, clean, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol";}body a {color: #4078c0;text-decoration: none;}body a:hover,body a:active {text-decoration: underline;}body hr {height: 0;margin: 15px 0;overflow: hidden;background: transparent;border: 0;border-bottom: 1px solid #ddd;}body hr:before {display: table;content: "";}body hr:after {display: table;clear: both;content: "";}body h1,body h2,body h3,body h4,body h5,body h6 {margin-top: 15px;margin-bottom: 15px;line-height: 1.1;}body h1 {font-size: 30px;}body h2 {font-size: 21px;}body h3 {font-size: 16px;}body h4 {font-size: 14px;}body h5 {font-size: 12px;}body h6 {font-size: 11px;}body blockquote {margin: 0;}body ul,body ol {padding: 0;margin-top: 0;margin-bottom: 0;}body ol ol,body ul ol {list-style-type: lower-roman;}body ul ul ol,body ul ol ol,body ol ul ol,body ol ol ol {list-style-type: lower-alpha;}body dd {margin-left: 0;}body code {font-family: Consolas, "Liberation Mono", Menlo, Courier, monospace;font-size: 12px;}body pre {margin-top: 0;margin-bottom: 0;font: 12px Consolas, "Liberation Mono", Menlo, Courier, monospace;}body .select::-ms-expand {opacity: 0;}body .octicon {font: normal normal normal 16px/1 octicons-link;display: inline-block;text-decoration: none;text-rendering: auto;-webkit-font-smoothing: antialiased;-moz-osx-font-smoothing: grayscale;-webkit-user-select: none;-moz-user-select: none;-ms-user-select: none;user-select: none;}body .octicon-link:before {content: '\f05c';}body:before {display: table;content: "";}body:after {display: table;clear: both;content: "";}body>*:first-child {margin-top: 0 !important;}body>*:last-child {margin-bottom: 0 !important;}body a:not([href]) {color: inherit;text-decoration: none;}body .anchor {display: inline-block;padding-right: 2px;margin-left: -18px;}body .anchor:focus {outline: none;}body h1,body h2,body h3,body h4,body h5,body h6 {margin-top: 1em;margin-bottom: 16px;font-weight: bold;line-height: 1.4;}body h1 .octicon-link,body h2 .octicon-link,body h3 .octicon-link,body h4 .octicon-link,body h5 .octicon-link,body h6 .octicon-link {color: #000;vertical-align: middle;visibility: hidden;}body h1:hover .anchor,body h2:hover .anchor,body h3:hover .anchor,body h4:hover .anchor,body h5:hover .anchor,body h6:hover .anchor {text-decoration: none;}body h1:hover .anchor .octicon-link,body h2:hover .anchor .octicon-link,body h3:hover .anchor .octicon-link,body h4:hover .anchor .octicon-link,body h5:hover .anchor .octicon-link,body h6:hover .anchor .octicon-link {visibility: visible;}body h1 {padding-bottom: 0.3em;font-size: 1.75em;line-height: 1.2;}body h1 .anchor {line-height: 1;}body h2 {padding-bottom: 0.3em;font-size: 1.5em;line-height: 1.225;}body h2 .anchor {line-height: 1;}body h3 {font-size: 1.25em;line-height: 1.43;}body h3 .anchor {line-height: 1.2;}body h4 {font-size: 1em;}body h4 .anchor {line-height: 1.2;}body h5 {font-size: 1em;}body h5 .anchor {line-height: 1.1;}body h6 {font-size: 1em;color: #777;}body h6 .anchor {line-height: 1.1;}body p,body blockquote,body ul,body ol,body dl,body table,body pre {margin-top: 0;margin-bottom: 16px;}body hr {height: 4px;padding: 0;margin: 16px 0;background-color: #e7e7e7;border: 0 none;}body ul,body ol {padding-left: 2em;}body ul ul,body ul ol,body ol ol,body ol ul {margin-top: 0;margin-bottom: 0;}body li>p {margin-top: 16px;}body dl {padding: 0;}body dl dt {padding: 0;margin-top: 16px;font-size: 1em;font-style: italic;font-weight: bold;}body dl dd {padding: 0 16px;margin-bottom: 16px;}body blockquote {padding: 0 15px;color: #777;border-left: 4px solid #ddd;}body blockquote>:first-child {margin-top: 0;}body blockquote>:last-child {margin-bottom: 0;}body table {display: block;width: 100%;overflow: auto;word-break: normal;word-break: keep-all;}body table th {font-weight: bold;}body table th,body table td {padding: 6px 13px;border: 1px solid #ddd;}body table tr {background-color: #fff;border-top: 1px solid #ccc;}body table tr:nth-child(2n) {background-color: #f8f8f8;}body img {max-width: 100%;box-sizing: content-box;background-color: #fff;}body code {padding: 0;padding-top: 0;padding-bottom: 0;margin: 0;font-size: 85%;background-color: rgba(0,0,0,0.04);border-radius: 3px;}body code:before,body code:after {letter-spacing: -0.2em;content: "\00a0";}body pre>code {padding: 0;margin: 0;font-size: 100%;word-break: normal;white-space: pre;background: transparent;border: 0;}body .highlight {margin-bottom: 16px;}body .highlight pre,body pre {padding: 16px;overflow: auto;font-size: 85%;line-height: 1.45;background-color: #f7f7f7;border-radius: 3px;}body .highlight pre {margin-bottom: 0;word-break: normal;}body pre {word-wrap: normal;}body pre code {display: inline;max-width: initial;padding: 0;margin: 0;overflow: initial;line-height: inherit;word-wrap: normal;background-color: transparent;border: 0;}body pre code:before,body pre code:after {content: normal;}body kbd {display: inline-block;padding: 3px 5px;font-size: 11px;line-height: 10px;color: #555;vertical-align: middle;background-color: #fcfcfc;border: solid 1px #ccc;border-bottom-color: #bbb;border-radius: 3px;box-shadow: inset 0 -1px 0 #bbb;}body .pl-c {color: #969896;}body .pl-c1,body .pl-s .pl-v {color: #0086b3;}body .pl-e,body .pl-en {color: #795da3;}body .pl-s .pl-s1,body .pl-smi {color: #333;}body .pl-ent {color: #63a35c;}body .pl-k {color: #a71d5d;}body .pl-pds,body .pl-s,body .pl-s .pl-pse .pl-s1,body .pl-sr,body .pl-sr .pl-cce,body .pl-sr .pl-sra,body .pl-sr .pl-sre {color: #183691;}body .pl-v {color: #ed6a43;}body .pl-id {color: #b52a1d;}body .pl-ii {background-color: #b52a1d;color: #f8f8f8;}body .pl-sr .pl-cce {color: #63a35c;font-weight: bold;}body .pl-ml {color: #693a17;}body .pl-mh,body .pl-mh .pl-en,body .pl-ms {color: #1d3e81;font-weight: bold;}body .pl-mq {color: #008080;}body .pl-mi {color: #333;font-style: italic;}body .pl-mb {color: #333;font-weight: bold;}body .pl-md {background-color: #ffecec;color: #bd2c00;}body .pl-mi1 {background-color: #eaffea;color: #55a532;}body .pl-mdr {color: #795da3;font-weight: bold;}body .pl-mo {color: #1d3e81;}body kbd {display: inline-block;padding: 3px 5px;font: 11px Consolas, "Liberation Mono", Menlo, Courier, monospace;line-height: 10px;color: #555;vertical-align: middle;background-color: #fcfcfc;border: solid 1px #ccc;border-bottom-color: #bbb;border-radius: 3px;box-shadow: inset 0 -1px 0 #bbb;}body .task-list-item {list-style-type: none;}body .task-list-item+.task-list-item {margin-top: 3px;}body .task-list-item input {margin: 0 0.35em 0.25em -1.6em;vertical-align: middle;}body :checked+.radio-label {z-index: 1;position: relative;border-color: #4078c0;}</style>
  
    
  
</head>
<body>
<h1 id="cvar-class">CVAR Class</h1>
<p>The <code>CVAR</code> class implements a <code>VARIANT</code> data type. The variant data type is a tagged union that can be used to represent any other data type. While lacking in efficiency, they are heavily used in COM Automation for its flexibility. The main purpose of the <code>CVAR</code> class is to make its use as easy as possible when you need to use them to work with COM Automation objects.</p>
<p><strong>Include file</strong>: CVAR.INC.</p>
<table>
<thead>
<tr class="header">
<th>Name</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><a href="#Constructors">Constructors</a></td>
<td>Initialize the class with the specified value.</td>
</tr>
<tr class="even">
<td><a href="#Operators">Operators</a></td>
<td>Procedures that perform a certain function with their operands.</td>
</tr>
<tr class="odd">
<td><a href="#vType">vType</a></td>
<td>Returns the VARIANT type.</td>
</tr>
<tr class="even">
<td><a href="#bstr">bstr</a></td>
<td>Extracts the content of the underlying variant and returns it as a CBSTR.</td>
</tr>
<tr class="odd">
<td><a href="#sptr">sptr</a></td>
<td>Returns the address of the underlying variant. Same as vptr but without clearing the variant.</td>
</tr>
<tr class="even">
<td><a href="#vptr">vptr</a></td>
<td>Clears the CVAR and returns the address of the underlying variant.</td>
</tr>
<tr class="odd">
<td><a href="#wstr">wstr</a></td>
<td>Extracts the content of the underlying variant and returns it as a CWSTR.</td>
</tr>
<tr class="even">
<td><a href="#Attach">Attach</a></td>
<td>Attaches a variant to the class.</td>
</tr>
<tr class="odd">
<td><a href="#Detach">Detach</a></td>
<td>Detaches the variant data from this class and transfers ownership to the passed variant.</td>
</tr>
<tr class="even">
<td><a href="#ChangeType">ChangeType</a></td>
<td>Converts the variant from one type to another.</td>
</tr>
<tr class="odd">
<td><a href="#ChangeTypeEx">ChangeTypeEx</a></td>
<td>Converts the variant from one type to another.</td>
</tr>
<tr class="even">
<td><a href="#GetDim">GetDim</a></td>
<td>Gets the number of dimensions in the array.</td>
</tr>
<tr class="odd">
<td><a href="#GetLBound">GetLBound</a></td>
<td>Gets the lower bound for the specified dimension of the safe array.</td>
</tr>
<tr class="even">
<td><a href="#GetUBound">GetUBound</a></td>
<td>Gets the upper bound for the specified dimension of the safe array.</td>
</tr>
<tr class="odd">
<td><a href="#GetElementCount">GetElementCount</a></td>
<td>Gets the number of elements in the array.</td>
</tr>
<tr class="even">
<td><a href="#DecToCY">DecToCY</a></td>
<td>Converts a CVAR of type decimal to a CY structure.</td>
</tr>
<tr class="odd">
<td><a href="#DecToDouble">DecToDouble</a></td>
<td>Converts a CVAR of type decimal to a double.</td>
</tr>
<tr class="even">
<td><a href="#Round">Round</a></td>
<td>Rounds a variant to the specified number of decimal places.</td>
</tr>
<tr class="odd">
<td><a href="#FormatNumber">FormatNumber</a></td>
<td>Formats a CVAR containing numbers into a string form.</td>
</tr>
<tr class="even">
<td><a href="#GetBooleanElem">GetBooleanElem</a></td>
<td>Extracts a single boolean element from a safe array of booleans.</td>
</tr>
<tr class="odd">
<td><a href="#GetDoubleElem">GetDoubleElem</a></td>
<td>Extracts a single DOUBLE element from a safe array of doubles.</td>
</tr>
<tr class="even">
<td><a href="#GetLongElem">GetLongElem</a></td>
<td>Extracts a single LONG element from a safe array of longs.</td>
</tr>
<tr class="odd">
<td><a href="#GetLongIntElem">GetLongIntElem</a></td>
<td>Extracts a single LONGINT element from a safe array of long integers.</td>
</tr>
<tr class="even">
<td><a href="#GetShortElem">GetShortElem</a></td>
<td>Extracts a single SHORT element from a safe array of shorts.</td>
</tr>
<tr class="odd">
<td><a href="#GetStringElem">GetStringElem</a></td>
<td>Extracts a single BSTR element from a safe array of unicode strings.</td>
</tr>
<tr class="even">
<td><a href="#GetULongElem">GetULongElem</a></td>
<td>Extracts a single ULONG element from a safe array of unsigned longs.</td>
</tr>
<tr class="odd">
<td><a href="#GetULongIntElem">GetULongIntElem</a></td>
<td>Extracts a single ULONGINT element from a safe array of unsigned long integers.</td>
</tr>
<tr class="even">
<td><a href="#GetUShortElem">GetUShortElem</a></td>
<td>Extracts a single USHORT element from a safe array of unsigned shorts.</td>
</tr>
<tr class="odd">
<td><a href="#GetVariantElem">GetVariantElem</a></td>
<td>Extracts a single Variant element from a safe array of variants.</td>
</tr>
<tr class="even">
<td><a href="#Put">Put</a></td>
<td>Assigns values to a CVAR.</td>
</tr>
<tr class="odd">
<td><a href="#PutNull">PutNull</a></td>
<td>Assigns a null value.</td>
</tr>
<tr class="even">
<td><a href="#PutBool">PutBool</a></td>
<td>Assigns a boolean value.</td>
</tr>
<tr class="odd">
<td><a href="#PutBoolean">PutBoolean</a></td>
<td>Assigns a boolean value.</td>
</tr>
<tr class="even">
<td><a href="#PutByte">PutByte</a></td>
<td>Assigns a byte value.</td>
</tr>
<tr class="odd">
<td><a href="#PutUByte">PutUByte</a></td>
<td>Assigns an ubyte value.</td>
</tr>
<tr class="even">
<td><a href="#PutShort">PutShort</a></td>
<td>Assigns a short value.</td>
</tr>
<tr class="odd">
<td><a href="#PutUShort">PutUShort</a></td>
<td>Assigns an ushort value.</td>
</tr>
<tr class="even">
<td><a href="#PutInt">PutInt</a></td>
<td>Assigns an int_ value.</td>
</tr>
<tr class="odd">
<td><a href="#PutUInt">PutUInt</a></td>
<td>Assigns an uint value.</td>
</tr>
<tr class="even">
<td><a href="#PutLong">PutLong</a></td>
<td>Assigns a long value.</td>
</tr>
<tr class="odd">
<td><a href="#PutULong">PutULong</a></td>
<td>Assigns an ulong value.</td>
</tr>
<tr class="even">
<td><a href="#PutLongInt">PutLongInt</a></td>
<td>Assigns a longint value.</td>
</tr>
<tr class="odd">
<td><a href="#PutULongInt">PutULongInt</a></td>
<td>Assigns an ulongint value.</td>
</tr>
<tr class="even">
<td><a href="#PutSingle">PutSingle</a></td>
<td>Assigns a single value.</td>
</tr>
<tr class="odd">
<td><a href="#PutFloat">PutFloat</a></td>
<td>Assigns a single value.</td>
</tr>
<tr class="even">
<td><a href="#PutDouble">PutDouble</a></td>
<td>Assigns a double value.</td>
</tr>
<tr class="odd">
<td><a href="#PutBooleanArray">PutBooleanArray</a></td>
<td>Initializes CVAR from an array of Boolean values.</td>
</tr>
<tr class="even">
<td><a href="#PutShortArray">PutShortArray</a></td>
<td>Initializes CVAR from an array of signed 16-bit integer values.</td>
</tr>
<tr class="odd">
<td><a href="#PutUShortArray">PutUShortArray</a></td>
<td>Initializes CVAR from an array of unsigned 16-bit integer values.</td>
</tr>
<tr class="even">
<td><a href="#PutLongArray">PutLongArray</a></td>
<td>Initializes CVAR from an array of signed 32-bit integer values.</td>
</tr>
<tr class="odd">
<td><a href="#PutULongArray">PutULongArray</a></td>
<td>Initializes CVAR from an array of 32-bit unsigned integer values.</td>
</tr>
<tr class="even">
<td><a href="#PutLongIntArray">PutLongIntArray</a></td>
<td>Initializes CVAR from an array of signed 64-bit integer values.</td>
</tr>
<tr class="odd">
<td><a href="#PutULongIntArray">PutULongIntArray</a></td>
<td>Initializes CVAR from an array of unsigned 64-bit integer values.</td>
</tr>
<tr class="even">
<td><a href="#PutDoubleArray">PutDoubleArray</a></td>
<td>Initializes CVAR from an array of unsigned 64-bit integer values.</td>
</tr>
<tr class="odd">
<td><a href="#PutStringArray">PutStringArray</a></td>
<td>Initializes CVAR from an array of unsigned 64-bit integer values.</td>
</tr>
<tr class="even">
<td><a href="#PutBuffer">PutBuffer</a></td>
<td>Initializes CVAR with the contents of a buffer.</td>
</tr>
<tr class="odd">
<td><a href="#PutDateString">PutDateString</a></td>
<td>Initializes CVAR VT_DATE from a string.</td>
</tr>
<tr class="even">
<td><a href="#PutDec">PutDec</a></td>
<td>Initializes CVAR with the contents of a DECIMAL structure.</td>
</tr>
<tr class="odd">
<td><a href="#PutDecFromCY">PutDecFromCY</a></td>
<td>Converts a currency value to a variant of type VT_DECIMAL.</td>
</tr>
<tr class="even">
<td><a href="#PutDecFromDouble">PutDecFromDouble</a></td>
<td>Converts a double value to a variant of type VT_DECIMAL.</td>
</tr>
<tr class="odd">
<td><a href="#PutDecFromStr">PutDecFromStr</a></td>
<td>Initializes CVAR as VT_DECIMAL from a string.</td>
</tr>
<tr class="even">
<td><a href="#PutFileTime">PutFileTime</a></td>
<td>Initializes CVAR with the contents of a FILETIME structure.</td>
</tr>
<tr class="odd">
<td><a href="#PutFileTimeArray">PutFileTimeArray</a></td>
<td>Initializes CVAR with an array of FILETIME structures.</td>
</tr>
<tr class="even">
<td><a href="#PutGuid">PutGuid</a></td>
<td>Initializes CVAR from a GUID.</td>
</tr>
<tr class="odd">
<td><a href="#PutPropVariant">PutPropVariant</a></td>
<td>Initializes CVAR from the contents of a PROPVARIANT structure.</td>
</tr>
<tr class="even">
<td><a href="#PutRecord">PutRecord</a></td>
<td>Initializes CVAR with a reference to an UDT.</td>
</tr>
<tr class="odd">
<td><a href="#PutRef">PutRef</a></td>
<td>Assigns a value by reference (a pointer to a variable).</td>
</tr>
<tr class="even">
<td><a href="#PutResource">PutResource</a></td>
<td>Initializes the CVAR based on a string resource imbedded in an executable file.</td>
</tr>
<tr class="odd">
<td><a href="#PutSafeArray">PutSafeArray</a></td>
<td>Initializes CVAR from a safe array.</td>
</tr>
<tr class="even">
<td><a href="#PutStrRet">PutStrRet</a></td>
<td>Initializes CVAR with string stored in a STRRET structure.</td>
</tr>
<tr class="odd">
<td><a href="#PutSystemTime">PutSystemTime</a></td>
<td>Initializes CVAR with the contents of a SYSTEMTIME structure.</td>
</tr>
<tr class="even">
<td><a href="#PutUtf8">PutUtf8</a></td>
<td>Initializes CVAR with the contents of an UTF-8 string.</td>
</tr>
<tr class="odd">
<td><a href="#PutVariantArrayElem">PutVariantArrayElem</a></td>
<td>Initializes CVAR with a value stored in another VARIANT structure.</td>
</tr>
<tr class="even">
<td><a href="#PutVbDate">PutVbDate</a></td>
<td>Initializes CVAR with the contents of a DATE value.</td>
</tr>
<tr class="odd">
<td><a href="#ToBooleanArray">ToBooleanArray</a></td>
<td>Extracts an array of boolean values from CVAR.</td>
</tr>
<tr class="even">
<td><a href="#ToBooleanArrayAlloc">ToBooleanArrayAlloc</a></td>
<td>Extracts an array of boolean values from CVAR.</td>
</tr>
<tr class="odd">
<td><a href="#ToBstr">ToBstr</a></td>
<td>Extracts the content of the underlying variant and returns it as a CBSTR.</td>
</tr>
<tr class="even">
<td><a href="#ToBuffer">ToBuffer</a></td>
<td>Extracts the contents of a CVAR of type VT_ARRRAY OR VT_UI1 to a buffer.</td>
</tr>
<tr class="odd">
<td><a href="#ToBufferString">ToBuffer (STRING)</a></td>
<td>Extracts the contents of a CVAR of type VT_ARRRAY OR VT_UI1 to a string used as a buffer.</td>
</tr>
<tr class="even">
<td><a href="#ToDosDateTime">ToDosDateTime</a></td>
<td>Extracts a date and time value in Microsoft MS-DOS format from a CVAR of type VT_DATE.</td>
</tr>
<tr class="odd">
<td><a href="#ToDoubleArray">ToDoubleArray</a></td>
<td>Extracts an array of DOUBLE values from CVAR.</td>
</tr>
<tr class="even">
<td><a href="#ToDoubleArrayAlloc">ToDoubleArrayAlloc</a></td>
<td>Extracts an array of DOUBLE values from CVAR.</td>
</tr>
<tr class="odd">
<td><a href="#ToFileTime">ToFileTime</a></td>
<td>Returns the contents of a CVAR of type VT_DATE as a FILETIME structure.</td>
</tr>
<tr class="even">
<td><a href="#ToGuid">ToGuid</a></td>
<td>Returns the contents of a CVAR containing a GUID string as a GUID structure.</td>
</tr>
<tr class="odd">
<td><a href="#ToGuidBStr">ToGuidBStr</a></td>
<td>Returns the contents of a CVAR containing a GUID string as an unicode GUID string.</td>
</tr>
<tr class="even">
<td><a href="#ToGuidStr">ToGuidStr</a></td>
<td>Returns the contents of a CVAR containing a GUID string as an unicode GUID string.</td>
</tr>
<tr class="odd">
<td><a href="#ToGuidWStr">ToGuidWStr</a></td>
<td>Returns the contents of a CVAR containing a GUID string as an unicode GUID string.</td>
</tr>
<tr class="even">
<td><a href="#ToLongArray">ToLongArray</a></td>
<td>Extracts an array of LONG values from CVAR.</td>
</tr>
<tr class="odd">
<td><a href="#ToLongArrayAlloc">ToLongArrayAlloc</a></td>
<td>Extracts an array of LONG values from CVAR.</td>
</tr>
<tr class="even">
<td><a href="#ToLongIntArray">ToLongIntArray</a></td>
<td>Extracts an array of LONGINT values from CVAR.</td>
</tr>
<tr class="odd">
<td><a href="#ToLongIntArrayAlloc">ToLongIntArrayAlloc</a></td>
<td>Extracts an array of LONGINT values from CVAR.</td>
</tr>
<tr class="even">
<td><a href="#ToShortArray">ToShortArray</a></td>
<td>Extracts an array of Int16 values from CVAR.</td>
</tr>
<tr class="odd">
<td><a href="#ToShortArrayAlloc">ToShortArrayAlloc</a></td>
<td>Extracts an array of SHORT values from CVAR.</td>
</tr>
<tr class="even">
<td><a href="#ToStr">ToStr</a></td>
<td>Extracts the content of the underlying variant and returns it as a CWSTR.</td>
</tr>
<tr class="odd">
<td><a href="#ToStringArray">ToStringArray</a></td>
<td>Extracts data from a vector structure into a PWSTR array.</td>
</tr>
<tr class="even">
<td><a href="#ToStringArrayAlloc">ToStringArrayAlloc</a></td>
<td>Extracts an array of PWSTR values from CVAR.</td>
</tr>
<tr class="odd">
<td><a href="#ToStrRet">ToStrRet</a></td>
<td>Returns the contents of a CVAR of type VT_BSTR to a STRRET stucture.</td>
</tr>
<tr class="even">
<td><a href="#ToSystemTime">ToSystemTime</a></td>
<td>Returns the contents of CVAR of type VT_DATE as a FILETIME structure.</td>
</tr>
<tr class="odd">
<td><a href="#ToULongArray">ToULongArray</a></td>
<td>Extracts an array of ULONG values from CVAR.</td>
</tr>
<tr class="even">
<td><a href="#ToULongArrayAlloc">ToULongArrayAlloc</a></td>
<td>Extracts an array of ULONG values from CVAR.</td>
</tr>
<tr class="odd">
<td><a href="#ToULongIntArray">ToULongIntArray</a></td>
<td>Extracts an array of ULONGINT values from CVAR.</td>
</tr>
<tr class="even">
<td><a href="#ToULongIntArrayAlloc">ToULongIntArrayAlloc</a></td>
<td>Extracts an array of ULONGINT values from CVAR.</td>
</tr>
<tr class="odd">
<td><a href="#ToUShortArray">ToUShortArray</a></td>
<td>Extracts an array of USHORT values from CVAR.</td>
</tr>
<tr class="even">
<td><a href="#ToUShortArrayAlloc">ToUShortArrayAlloc</a></td>
<td>Extracts an array of USHORT values from CVAR.</td>
</tr>
<tr class="odd">
<td><a href="#ToUtf8">ToUtf8</a></td>
<td>Returns the contents of a CVAR containing a BSTR as an UTF-8 encoded string.</td>
</tr>
<tr class="even">
<td><a href="#ToVbDate">ToVbDate</a></td>
<td>Returns the contents of a CVAR of type VT_DATE as a DATE value.</td>
</tr>
<tr class="odd">
<td><a href="#ToWStr">ToWStr</a></td>
<td>Extracts the content of the underlying variant and returns it as a CWSTR.</td>
</tr>
</tbody>
</table>
<h4 id="numeric-conversions">Numeric Conversions</h4>
<table>
<thead>
<tr class="header">
<th>Name</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><a href="#ValDouble">ValDouble</a></td>
<td>Converts the variant to a floating point number (DOUBLE).</td>
</tr>
<tr class="even">
<td><a href="#ValInt">ValInt</a></td>
<td>Converts the variant to a signed 32-bit integer (LONG).</td>
</tr>
<tr class="odd">
<td><a href="#ValLong">ValLong</a></td>
<td>Converts the variant to a signed 32-bit integer (LONG).</td>
</tr>
<tr class="even">
<td><a href="#ValLongInt">ValLongInt</a></td>
<td>Converts the variant to a signed 64-bit integer (LONGINT).</td>
</tr>
<tr class="odd">
<td><a href="#Value">Value</a></td>
<td>Converts the variant to a floating point number (DOUBLE).</td>
</tr>
<tr class="even">
<td><a href="#ValUInt">ValUInt</a></td>
<td>Converts the variant to a 32.bit unsigned integer (ULONG).</td>
</tr>
<tr class="odd">
<td><a href="#ValULong">ValULong</a></td>
<td>Converts the variant to a 32-bit unsigned integer (ULONG).</td>
</tr>
<tr class="even">
<td><a href="#ValULongInt">ValULongInt</a></td>
<td>Converts the variant to a 64-bit unsigned integer (ULONGINT).</td>
</tr>
</tbody>
</table>
<h4 id="helper-procedures">Helper Procedures</h4>
<table>
<thead>
<tr class="header">
<th>Name</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><a href="#AfxCVarToStr">AfxCVarToStr</a></td>
<td>Extracts the contents of a CVAR to a CWSTR.</td>
</tr>
<tr class="even">
<td><a href="#AfxCVariantToBuffer">AfxCVariantToBuffer</a></td>
<td>Extracts the contents of a variant that contains an array of bytes.</td>
</tr>
<tr class="odd">
<td><a href="#AfxCVarOptPrm">AfxCVarOptPrm</a></td>
<td>Returns a CVAR suitable to be used with optional parameters.</td>
</tr>
</tbody>
</table>
<h1 id="constructors"><a name="Constructors"></a>Constructors</h1>
<p>Creates a an instance of the CVAR class.</p>
<pre><code>CONSTRUCTOR
CONSTRUCTOR (BYREF cv AS CVAR)
CONSTRUCTOR (BYVAL v AS VARIANT)
CONSTRUCTOR (BYREF wsz AS WSTRING)
CONSTRUCTOR (BYREF cws AS CWSTR)
CONSTRUCTOR (BYREF cbs AS CBSTR)
CONSTRUCTOR (BYVAL pvar AS VARIANT PTR)
CONSTRUCTOR (BYVAL cy AS CURRENCY)
CONSTRUCTOR (BYVAL dec AS DECIMAL)
DECLARE CONSTRUCTOR (BYVAL b AS BOOLEAN)
CONSTRUCTOR (BYREF pDisp AS IDispatch PTR, BYVAL fAddRef AS BOOLEAN = FALSE)
CONSTRUCTOR (BYREF pUnk AS IUnknown PTR, BYVAL fAddRef AS BOOLEAN = FALSE)
CONSTRUCTOR (BYVAL _value AS LONGINT, BYVAL _vType AS WORD = VT_I4)
CONSTRUCTOR (BYVAL _value AS DOUBLE, BYVAL _vType AS WORD = VT_R8)
CONSTRUCTOR (BYVAL _value AS LONGINT, BYREF strType AS STRING)
CONSTRUCTOR (BYVAL _value AS DOUBLE, BYREF strType AS STRING)
CONSTRUCTOR (BYVAL _pvar AS ANY PTR, BYVAL _vType AS WORD)
CONSTRUCTOR (BYVAL _pvar AS ANY PTR, BYREF strType AS STRING)
</code></pre>
<table>
<thead>
<tr class="header">
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><em>cv</em></td>
<td>A CVAR.</td>
</tr>
<tr class="even">
<td><em>v</em></td>
<td>A VARIANT.</td>
</tr>
<tr class="odd">
<td><em>pvar</em></td>
<td>Pointer to a VARIANT.</td>
</tr>
<tr class="even">
<td><em>cy</em></td>
<td>A currency structure.</td>
</tr>
<tr class="odd">
<td><em>dec</em></td>
<td>A decimal structure.</td>
</tr>
<tr class="even">
<td><em>b</em></td>
<td>A boolean value (TRUE or FALSE).</td>
</tr>
<tr class="odd">
<td><em>pwsz</em></td>
<td>Pointer to an unicode string. You can also pass a Free Basic ansi string or a string literal.</td>
</tr>
<tr class="even">
<td><em>cbs</em></td>
<td>A CBSTR.</td>
</tr>
<tr class="odd">
<td><em>cws</em></td>
<td>A CWSTR.</td>
</tr>
<tr class="even">
<td><em>pDisp</em></td>
<td>Pointer to a DISPATCH interface.</td>
</tr>
<tr class="odd">
<td><em>pUnk</em></td>
<td>Pointer to a UNKNOWN interface.</td>
</tr>
<tr class="even">
<td><em>_value</em></td>
<td>A numeric value or variable.</td>
</tr>
<tr class="odd">
<td><em>_pvar</em></td>
<td>Pointer to a variable. This will create a VT_BYREF variant of the specified type.</td>
</tr>
<tr class="even">
<td><em>_vtype</em></td>
<td>The variant type, e.g. VT_I4, VT_UI4.</td>
</tr>
<tr class="odd">
<td><em>strType</em></td>
<td>The variant type as a string: &quot;BOOL&quot;, &quot;BYTE&quot;, &quot;UBYTE&quot;, &quot;SHORT&quot;, &quot;USHORT, &quot;INT&quot;, UINT&quot;, &quot;LONG&quot;, &quot;ULONG&quot;, &quot;LONGINT&quot;, &quot;SINGLE, &quot;DOUBLE&quot;, &quot;NULL&quot;.</td>
</tr>
<tr class="even">
<td><em>fAddRef</em></td>
<td>TRUE or FALSE. If TRUE, increases the reference count of the passed interface.</td>
</tr>
</tbody>
</table>
<h1 id="operators"><a name="Operators"></a>Operators</h1>
<p>Procedures that perform a certain function with their operands. They do the same actions that the native FreeBasic operators but with variants. For detailed descriptions see the FreeBasic documentation.</p>
<p>Global Operators</p>
<pre><code>OPERATOR &amp; (BYREF cv1 AS CVAR, BYREF cv2 AS CVAR) AS CVAR
OPERATOR * (BYREF cv AS CVAR) AS VARIANT PTR
</code></pre>
<p>Cast Operators</p>
<pre><code>OPERATOR Cast () AS VARIANT
OPERATOR Cast () AS VARIANT PTR
</code></pre>
<p>Assignment operators</p>
<pre><code>OPERATOR Let (BYREF cv AS CVAR)
OPERATOR Let (BYVAL v AS VARIANT)
OPERATOR Let (BYVAL pvar AS VARIANT PTR)
OPERATOR Let (BYVAL cy AS CURRENCY)
OPERATOR Let (BYVAL dec AS DECIMAL)
OPERATOR Let (BYVAL b AS BOOLEAN)
OPERATOR Let (BYREF cbs AS CBSTR)
OPERATOR Let (BYREF cws AS CWSTR)
OPERATOR Let (BYREF pDisp AS IDispatch PTR)
OPERATOR Let (BYREF pUnk AS IUnknown PTR)
OPERATOR Let (BYVAL _value AS LONGINT)
OPERATOR Let (BYVAL _value AS DOUBLE)
OPERATOR += (BYREF cv AS CVAR)
OPERATOR -= (BYREF cv AS CVAR)
OPERATOR *= (BYREF cv AS CVAR)
OPERATOR /= (BYREF cv AS CVAR)
OPERATOR \= (BYREF cv AS CVAR)
OPERATOR Mod= (BYREF cv AS CVAR)
OPERATOR Imp= (BYREF cv AS CVAR)
OPERATOR Eqv= (BYREF cv AS CVAR)
OPERATOR ^= (BYREF cv AS CVAR)
</code></pre>
<p>Arithmetic operators</p>
<pre><code>OPERATOR + (BYREF cv1 AS CVAR, BYREF cv2 AS CVAR) AS CVAR
OPERATOR - (BYREF cv1 AS CVAR, BYREF cv2 AS CVAR) AS CVAR
OPERATOR * (BYREF cv1 AS CVAR, BYREF cv2 AS CVAR) AS CVAR
OPERATOR / (BYREF cv1 AS CVAR, BYREF cv2 AS CVAR) AS CVAR
OPERATOR \ (BYREF cv1 AS CVAR, BYREF cv2 AS CVAR) AS CVAR
OPERATOR ^ (BYREF cv1 AS CVAR, BYREF cv2 AS CVAR) AS DOUBLE
OPERATOR Mod (BYREF cv1 AS CVAR, BYREF cv2 AS CVAR) AS INTEGER
OPERATOR - (BYREF cv AS CVAR) AS CVAR
</code></pre>
<p>Relational operators</p>
<pre><code>OPERATOR = (BYREF cv1 AS CVAR, BYREF cv2 AS CVAR) AS BOOLEAN
OPERATOR &lt;&gt; (BYREF cv1 AS CVAR, BYREF cv2 AS CVAR) AS BOOLEAN
OPERATOR &lt; (BYREF cv1 AS CVAR, BYREF cv2 AS CVAR) AS BOOLEAN
OPERATOR &gt; (BYREF cv1 AS CVAR, BYREF cv2 AS CVAR) AS BOOLEAN
OPERATOR &lt;= (BYREF cv1 AS CVAR, BYREF cv2 AS CVAR) AS BOOLEAN
OPERATOR &gt;= (BYREF cv1 AS CVAR, BYREF cv2 AS CVAR) AS BOOLEAN
</code></pre>
<p>Bitwise operators</p>
<pre><code>OPERATOR And (BYREF cv1 AS CVAR, BYREF cv2 AS CVAR) AS INTEGER
OPERATOR Eqv (BYREF cv1 AS CVAR, BYREF cv2 AS CVAR) AS INTEGER
OPERATOR Imp (BYREF cv1 AS CVAR, BYREF cv2 AS CVAR) AS INTEGER
OPERATOR Not (BYREF cv AS CVAR) AS INTEGER
OPERATOR Or (BYREF cv1 AS CVAR, BYREF cv2 AS CVAR) AS INTEGER
OPERATOR Xor (BYREF cv1 AS CVAR, BYREF cv2 AS CVAR) AS INTEGER
</code></pre>
<h1 id="vtype"><a name="vType"></a>vType</h1>
<p>Returns the VARIANT type.</p>
<pre><code>FUNCTION vType () AS VARTYPE
</code></pre>
<p>The following table shows the available data types and where these values can be used.</p>
<table>
<thead>
<tr class="header">
<th>Type</th>
<th>Description</th>
<th>VARIANT</th>
<th>Typedesc</th>
<th>Property set</th>
<th>Safe array</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>VT_EMPTY</td>
<td>Not specified.</td>
<td>X</td>
<td></td>
<td>X</td>
<td></td>
</tr>
<tr class="even">
<td>VT_NULL</td>
<td>Null.</td>
<td>X</td>
<td></td>
<td>X</td>
<td></td>
</tr>
<tr class="odd">
<td>VT_I1</td>
<td>BYTE. A character.</td>
<td>X</td>
<td>X</td>
<td>X</td>
<td>X</td>
</tr>
<tr class="even">
<td>VT_UI1</td>
<td>UBYTE. An unsigned character.</td>
<td>X</td>
<td>X</td>
<td>X</td>
<td>X</td>
</tr>
<tr class="odd">
<td>VT_I2</td>
<td>SHORT. A 2-byte integer.</td>
<td>X</td>
<td>X</td>
<td>X</td>
<td>X</td>
</tr>
<tr class="even">
<td>VT_UI2</td>
<td>USHORT. An unsigned short.</td>
<td>X</td>
<td>X</td>
<td>X</td>
<td>X</td>
</tr>
<tr class="odd">
<td>VT_I4</td>
<td>LONG. A 4-byte integer.</td>
<td>X</td>
<td>X</td>
<td>X</td>
<td>X</td>
</tr>
<tr class="even">
<td>VT_UI4</td>
<td>ULONG. An unsigned long.</td>
<td>X</td>
<td>X</td>
<td>X</td>
<td>X</td>
</tr>
<tr class="odd">
<td>VT_I8</td>
<td>LONGINT. A 64-bit integer.</td>
<td>X</td>
<td>X</td>
<td>X</td>
<td>X</td>
</tr>
<tr class="even">
<td>VT_UI8</td>
<td>ULONGINT. A 64-bit unsigned integer.</td>
<td>X</td>
<td>X</td>
<td>X</td>
<td>X</td>
</tr>
<tr class="odd">
<td>VT_INT</td>
<td>LONG. An integer.</td>
<td>X</td>
<td>X</td>
<td>X</td>
<td>X</td>
</tr>
<tr class="even">
<td>VT_UINT</td>
<td>ULOG. An unsigned integer.</td>
<td>X</td>
<td>X</td>
<td></td>
<td>X</td>
</tr>
<tr class="odd">
<td>VT_R4</td>
<td>SINGLE. A 4-byte real.</td>
<td>X</td>
<td>X</td>
<td>X</td>
<td>X</td>
</tr>
<tr class="even">
<td>VT_R8</td>
<td>DOUBLE. A 8-byte real.</td>
<td>X</td>
<td>X</td>
<td>X</td>
<td>X</td>
</tr>
<tr class="odd">
<td>VT_CY</td>
<td>CY. Currency.</td>
<td>X</td>
<td>X</td>
<td>X</td>
<td>X</td>
</tr>
<tr class="even">
<td>VT_DATE</td>
<td>DOUBLE. A date.</td>
<td>X</td>
<td>X</td>
<td>X</td>
<td>X</td>
</tr>
<tr class="odd">
<td>VT_BSTR</td>
<td>BSTR. A string.</td>
<td>X</td>
<td>X</td>
<td>X</td>
<td>X</td>
</tr>
<tr class="even">
<td>VT_DISPATCH</td>
<td>IDispatch PTR. An IDispatch pointer.</td>
<td>X</td>
<td>X</td>
<td></td>
<td>X</td>
</tr>
<tr class="odd">
<td>VT_ERROR</td>
<td>SCODE. An SCODE value.</td>
<td>X</td>
<td>X</td>
<td>X</td>
<td>X</td>
</tr>
<tr class="even">
<td>VT_BOOL</td>
<td>BOOLEAN. A Boolean value<br>(True = -1, False = 0)</td>
<td>X</td>
<td>X</td>
<td>X</td>
<td>X</td>
</tr>
<tr class="odd">
<td>VT_VARIANT</td>
<td>VARIANT PTR. A variant pointer.</td>
<td>X</td>
<td>X</td>
<td>X</td>
<td>X</td>
</tr>
<tr class="even">
<td>VT_UNKNOWN</td>
<td>IUnknown PTR. An IUnknown pointer.</td>
<td>X</td>
<td>X</td>
<td></td>
<td>X</td>
</tr>
<tr class="odd">
<td>VT_DECIMAL</td>
<td>DECIMAL PTR. A 16-byte fixed-pointer value.</td>
<td>X</td>
<td>X</td>
<td></td>
<td>X</td>
</tr>
<tr class="even">
<td>VT_VOID</td>
<td>NULL. A C-style void.</td>
<td></td>
<td></td>
<td>X</td>
<td></td>
</tr>
<tr class="odd">
<td>VT_HRESULT</td>
<td>HRESULT. An HRESULT value.</td>
<td></td>
<td></td>
<td>X</td>
<td></td>
</tr>
<tr class="even">
<td>VT_PTR</td>
<td>A pointer type.</td>
<td></td>
<td></td>
<td>X</td>
<td></td>
</tr>
<tr class="odd">
<td>VT_SAFEARRAY</td>
<td>SAFEARRAY PTR. A safe array.<br>Use VT_ARRAY in VARIANT.</td>
<td></td>
<td>X</td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td>VT_CARRAY</td>
<td>A C-style array.</td>
<td></td>
<td>X</td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td>VT_USERDEFINED</td>
<td>A user-defined type.</td>
<td></td>
<td></td>
<td>X</td>
<td></td>
</tr>
<tr class="even">
<td>VT_LPSTR</td>
<td>ZSTRING. A null-terminated string.</td>
<td></td>
<td>X</td>
<td>X</td>
<td></td>
</tr>
<tr class="odd">
<td>VT_LPWSTR</td>
<td>WSTRING. A wide null-terminated string.</td>
<td></td>
<td>X</td>
<td>X</td>
<td></td>
</tr>
<tr class="even">
<td>VT_RECORD</td>
<td>A user-defined type.</td>
<td>X</td>
<td>X</td>
<td></td>
<td>X</td>
</tr>
<tr class="odd">
<td>VT_INT_PTR</td>
<td>A signed machine register size width.</td>
<td></td>
<td></td>
<td>X</td>
<td></td>
</tr>
<tr class="even">
<td>VT_UINT_PTR</td>
<td>An unsigned machine register size width.</td>
<td></td>
<td></td>
<td>X</td>
<td></td>
</tr>
<tr class="odd">
<td>VT_FILETIME</td>
<td>FILETIME. A FILETIME value.</td>
<td></td>
<td></td>
<td>X</td>
<td></td>
</tr>
<tr class="even">
<td>VT_BLOB</td>
<td>Length-prefixed bytes.</td>
<td></td>
<td></td>
<td>X</td>
<td></td>
</tr>
<tr class="odd">
<td>VT_STREAM</td>
<td>IStream PTR. The name of the stream follows.</td>
<td></td>
<td></td>
<td>X</td>
<td></td>
</tr>
<tr class="even">
<td>VT_STORAGE</td>
<td>The name of the storage follows.</td>
<td></td>
<td></td>
<td>X</td>
<td></td>
</tr>
<tr class="odd">
<td>VT_STREAMED_OBJECT</td>
<td>The stream contains an object.</td>
<td></td>
<td></td>
<td>X</td>
<td></td>
</tr>
<tr class="even">
<td>VT_STORED_OBJECT</td>
<td>The storage contains an object.</td>
<td></td>
<td></td>
<td>X</td>
<td></td>
</tr>
<tr class="odd">
<td>VT_BLOB_OBJECT</td>
<td>The blob contains an object.</td>
<td></td>
<td></td>
<td>X</td>
<td></td>
</tr>
<tr class="even">
<td>VT_CF</td>
<td>A clipboard format.</td>
<td></td>
<td></td>
<td>X</td>
<td></td>
</tr>
<tr class="odd">
<td>VT_CLSID</td>
<td>CLSID. A class ID.</td>
<td></td>
<td></td>
<td>X</td>
<td></td>
</tr>
<tr class="even">
<td>VT_VERSIONED_STREAM</td>
<td>A stream with a GUID version.</td>
<td></td>
<td></td>
<td>X</td>
<td></td>
</tr>
<tr class="odd">
<td>VT_BSTR_BLOB</td>
<td>Reserved for system use.</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td>VT_VECTOR</td>
<td>A simple counted array.</td>
<td></td>
<td></td>
<td>X</td>
<td></td>
</tr>
<tr class="odd">
<td>VT_ARRAY</td>
<td>SAFEARRAY PTR. A SAFEARRAY pointer.</td>
<td>X</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td>VT_BYREF</td>
<td>A void pointer for local use.</td>
<td>X</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td>VT_RESERVED</td>
<td>Reserved.</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td>VT_ILLEGAL</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td>VT_ILLEGALMASKED</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td>VT_TYPEMASK</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<h1 id="bstr"><a name="bstr"></a>bstr</h1>
<p>Extracts the content of the underlying variant and returns it as a CBSTR.</p>
<pre><code>FUNCTION bstr () AS CBSTR
</code></pre>
<h1 id="sptr"><a name="sptr"></a>sptr</h1>
<p>Returns the address of the underlying variant. Same as <strong>vptr</strong> but without clearing the variant.</p>
<pre><code>FUNCTION sptr () AS VARIANT PTR
</code></pre>
<h1 id="vptr"><a name="vptr"></a>vptr</h1>
<p>Clears the CVAR and returns the address of the underlying variant. Can be used to pass the variant to an OUT BYVAL VARIANT PTR parameter. If we pass a CVAR to a function with an OUT variant parameter without first clearing the contents of the CVAR, we may have a memory leak.</p>
<pre><code>FUNCTION vptr () AS VARIANT PTR
</code></pre>
<h1 id="wstr"><a name="wstr"></a>wstr</h1>
<p>Extracts the content of the underlying variant and returns it as a CWSTR.</p>
<pre><code>FUNCTION wstr () AS CWSTR
</code></pre>
<h1 id="attach"><a name="Attach"></a>Attach</h1>
<p>Attaches a variant to the class.</p>
<pre><code>FUNCTION Attach (BYVAL pvar AS VARIANT PTR) AS HRESULT
FUNCTION Attach (BYREF v AS VARIANT) AS HRESULT
</code></pre>
<table>
<thead>
<tr class="header">
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><em>pvar</em></td>
<td>Pointer to the variant to attach.</td>
</tr>
<tr class="even">
<td><em>v</em></td>
<td>The variant to attach.</td>
</tr>
</tbody>
</table>
<h4 id="remark">Remark</h4>
<p>Marks the source variant as VT_EMPTY instead of clearing it with VariantClear because we aren't making a duplicate of the contents, but transfering ownership.</p>
<h4 id="return-value">Return value</h4>
<p>Returns S_OK (0) or an HRESULT error code.</p>
<h1 id="detach"><a name="Detach"></a>Detach</h1>
<p>Detaches the variant data from this class and transfers ownership to the passed variant.</p>
<pre><code>FUNCTION Detach (BYVAL pvar AS VARIANT PTR) AS HRESULT
FUNCTION Detach (BYREF v AS VARIANT) AS HRESULT
</code></pre>
<table>
<thead>
<tr class="header">
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><em>pvar</em></td>
<td>Pointer to the variant where the contents of the variant data will be moved.</td>
</tr>
<tr class="even">
<td><em>v</em></td>
<td>Variant where the contents of the variant data will be moved.</td>
</tr>
</tbody>
</table>
<h4 id="remark-1">Remark</h4>
<p>This method transfers ownership of the underlying variant and marks it as empty.</p>
<h4 id="return-value-1">Return value</h4>
<p>Returns S_OK (0) or an HRESULT error code.</p>
<h1 id="changetype"><a name="ChangeType"></a>ChangeType</h1>
<p>Converts the variant from one type to another.</p>
<pre><code>FUNCTION ChangeType (BYVAL vtNew AS VARTYPE, BYVAL wFlags AS USHORT = 0) AS HRESULT
</code></pre>
<table>
<thead>
<tr class="header">
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><em>vtNew</em></td>
<td>The new variant type.</td>
</tr>
<tr class="even">
<td><em>wFlags</em></td>
<td><em>VARIANT_NOVALUEPROP</em> : Prevents the function from attempting to coerce an object to a fundamental type by getting the Value property. Applications should set this flag only if necessary, because it makes their behavior inconsistent with other applications.<br><em>VARIANT_ALPHABOOL</em> : Converts a VT_BOOL value to a string containing either &quot;True&quot; or &quot;False&quot;.<br><em>VARIANT_NOUSEROVERRIDE</em> : For conversions to or from VT_BSTR, passes LOCALE_NOUSEROVERRIDE to the core coercion routines.<br><em>VARIANT_LOCALBOOL</em> : For conversions from VT_BOOL to VT_BSTR and back, uses the language specified by the locale in use on the local computer.</td>
</tr>
</tbody>
</table>
<h4 id="return-value-2">Return value</h4>
<p>Returns S_OK (0) or an HRESULT error code.</p>
<h1 id="changetypeex"><a name="ChangeTypeEx"></a>ChangeTypeEx</h1>
<p>Converts the variant from one type to another.</p>
<pre><code>FUNCTION ChangeTypeEx (BYVAL vtNew AS VARTYPE, BYVAL lcid AS LCID = 0, BYVAL wFlags AS USHORT = 0) AS HRESULT
</code></pre>
<table>
<thead>
<tr class="header">
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><em>vtNew</em></td>
<td>The new variant type.</td>
</tr>
<tr class="even">
<td><em>lcid</em></td>
<td>The locale identifier. The LCID is useful when the type of the source or destination VARIANTARG is VT_BSTR, VT_DISPATCH, or VT_DATE.</td>
</tr>
<tr class="odd">
<td><em>wFlags</em></td>
<td><em>VARIANT_NOVALUEPROP</em> : Prevents the function from attempting to coerce an object to a fundamental type by getting the Value property. Applications should set this flag only if necessary, because it makes their behavior inconsistent with other applications.<br><em>VARIANT_ALPHABOOL</em> : Converts a VT_BOOL value to a string containing either &quot;True&quot; or &quot;False&quot;.<br><em>VARIANT_NOUSEROVERRIDE</em> : For conversions to or from VT_BSTR, passes LOCALE_NOUSEROVERRIDE to the core coercion routines.<br><em>VARIANT_LOCALBOOL</em> : For conversions from VT_BOOL to VT_BSTR and back, uses the language specified by the locale in use on the local computer.</td>
</tr>
</tbody>
</table>
<h4 id="return-value-3">Return value</h4>
<p>Returns S_OK (0) or an HRESULT error code.</p>
<h1 id="getdim"><a name="GetDim"></a>GetDim</h1>
<p>Gets the number of dimensions in the array.</p>
<pre><code>FUNCTION GetDim () AS ULONG
</code></pre>
<h4 id="return-value-4">Return value</h4>
<p>Returns the number of dimensions for variants of type VT_ARRAY; returns 0 otherwise.</p>
<h1 id="getlbound"><a name="GetLBound"></a>GetLBound</h1>
<p>Gets the lower bound for the specified dimension of the safe array.</p>
<pre><code>FUNCTION GetLBound (BYVAL nDim AS UINT = 1) AS LONG
</code></pre>
<table>
<thead>
<tr class="header">
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><em>nDim</em></td>
<td>The dimension of the array.</td>
</tr>
</tbody>
</table>
<h4 id="return-value-5">Return value</h4>
<p>Returns the lower bound for the specified dimension of the safe array for variants of type VT_ARRAY; returns 0 otherwise.</p>
<h1 id="getubound"><a name="GetUBound"></a>GetUBound</h1>
<p>Gets the upper bound for the specified dimension of the safe array.</p>
<pre><code>FUNCTION GetUBound (BYVAL nDim AS UINT = 1) AS LONG
</code></pre>
<table>
<thead>
<tr class="header">
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><em>nDim</em></td>
<td>The dimension of the array.</td>
</tr>
</tbody>
</table>
<h4 id="return-value-6">Return value</h4>
<p>Returns the upper bound for the specified dimension of the safe array for variants of type VT_ARRAY; returns 0 otherwise.</p>
<h1 id="getelementcount"><a name="GetElementCount"></a>GetElementCount</h1>
<p>Gets the number of elements in the array.</p>
<pre><code>FUNCTION GetElementCount () AS ULONG
</code></pre>
<h4 id="return-value-7">Return value</h4>
<p>Returns the number of elements for variants of type VT_ARRAY; returns 1 otherwise.</p>
<h1 id="dectocy"><a name="DecToCY"></a>DecToCY</h1>
<p>Converts a CVAR of type decimal to a CY structure.</p>
<pre><code>FUNCTION DecToCY () AS CY
</code></pre>
<h4 id="return-value-8">Return value</h4>
<p>Returns the contents of a VT_DECIMAL variant as a CY structure.</p>
<h1 id="dectodouble"><a name="DecToDouble"></a>DecToDouble</h1>
<p>Converts a CVAR of type decimal to a double.</p>
<pre><code>FUNCTION DecToDouble () AS DOUBLE
</code></pre>
<h4 id="return-value-9">Return value</h4>
<p>Returns the contents of a VT_DECIMAL variant as a DOUBLE.</p>
<h1 id="round"><a name="Round"></a>Round</h1>
<p>Rounds a variant to the specified number of decimal places.</p>
<pre><code>FUNCTION Round (BYREF cv AS CVAR, BYVAL cDecimals AS LONG) AS CVAR
</code></pre>
<table>
<thead>
<tr class="header">
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><em>cv</em></td>
<td>The CVAR to round.</td>
</tr>
<tr class="even">
<td><em>cDecimals</em></td>
<td>The number of decimal places.</td>
</tr>
</tbody>
</table>
<h4 id="return-value-10">Return value</h4>
<p>A CVAR containing the rounded result.</p>
<h1 id="formatnumber"><a name="FormatNumber"></a>FormatNumber</h1>
<p>Formats a CVAR containing numbers into a string form.</p>
<pre><code>FUNCTION FormatNumber (BYVAL iNumDig AS LONG = -1, BYVAL ilncLead AS LONG = -2, _
   BYVAL iUseParens AS LONG = -2, BYVAL iGroup AS LONG = -2, BYVAL dwFlags AS DWORD = 0) AS CBSTR
</code></pre>
<table>
<thead>
<tr class="header">
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><em>iNumDig</em></td>
<td>The number of digits to pad to after the decimal point. Specify -1 to use the system default value.</td>
</tr>
<tr class="even">
<td><em>ilncLead</em></td>
<td>Specifies whether to include the leading digit on numbers.<br>-2 : Use the system default.<br>-1 : Include the leading digit.<br> 0 : Do not include the leading digit.</td>
</tr>
<tr class="odd">
<td><em>iUseParens</em></td>
<td>Specifies whether negative numbers should use parentheses.<br>-2 : Use the system default.<br>-1 : Use parentheses.<br>0 : Do not use parentheses.</td>
</tr>
<tr class="even">
<td><em>iGroup</em></td>
<td>Specifies whether thousands should be grouped. For example 10,000 versus 10000.<br>-2 : Use the system default.<br>-1 : Group thousands.<br> 0 : Do not group thousands.</td>
</tr>
<tr class="odd">
<td><em>dwFlags</em></td>
<td>VAR_CALENDAR_HIJRI is the only flag that can be set.</td>
</tr>
</tbody>
</table>
<h4 id="return-value-11">Return value</h4>
<p>A CWSTR containing the formatted value.</p>
<h4 id="remarks">Remarks</h4>
<p>This function uses the user's default locale while calling VarTokenizeFormatString and VarFormatFromTokens.</p>
<h1 id="getbooleanelem"><a name="GetBooleanElem"></a>GetBooleanElem</h1>
<p>Extracts a single boolean element from a safe array of booleans.</p>
<pre><code>FUNCTION GetBooleanElem (BYVAL iElem AS ULONG) AS BOOLEAN
</code></pre>
<table>
<thead>
<tr class="header">
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><em>iElem</em></td>
<td>The index of the element of the array.</td>
</tr>
</tbody>
</table>
<h4 id="return-value-12">Return value</h4>
<p>The retrieved value.</p>
<h1 id="getdoubleelem"><a name="GetDoubleElem"></a>GetDoubleElem</h1>
<p>Extracts a single DOUBLE element from a safe array of doubles.</p>
<pre><code>FUNCTION GetDoubleElem (BYVAL iElem AS ULONG) AS DOUBLE
</code></pre>
<table>
<thead>
<tr class="header">
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><em>iElem</em></td>
<td>The index of the element of the array.</td>
</tr>
</tbody>
</table>
<h4 id="return-value-13">Return value</h4>
<p>The retrieved value.</p>
<h1 id="getlongelem"><a name="GetLongElem"></a>GetLongElem</h1>
<p>Extracts a single LONG element from a safe array of longs.</p>
<pre><code>FUNCTION GetLongElem (BYVAL iElem AS ULONG) AS LONG
</code></pre>
<table>
<thead>
<tr class="header">
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><em>iElem</em></td>
<td>The index of the element of the array.</td>
</tr>
</tbody>
</table>
<h4 id="return-value-14">Return value</h4>
<p>The retrieved value.</p>
<h1 id="getlongintelem"><a name="GetLongIntElem"></a>GetLongIntElem</h1>
<p>Extracts a single LONGINT element from a safe array of long integers.</p>
<pre><code>FUNCTION GetLongIntElem (BYVAL iElem AS ULONG) AS LONGINT
</code></pre>
<table>
<thead>
<tr class="header">
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><em>iElem</em></td>
<td>The index of the element of the array.</td>
</tr>
</tbody>
</table>
<h4 id="return-value-15">Return value</h4>
<p>The retrieved value.</p>
<h1 id="getshortelem"><a name="GetShortElem"></a>GetShortElem</h1>
<p>Extracts a single SHORT element from a safe array of short integers.</p>
<pre><code>FUNCTION GetShortElem (BYVAL iElem AS ULONG) AS SHORT
</code></pre>
<table>
<thead>
<tr class="header">
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><em>iElem</em></td>
<td>The index of the element of the array.</td>
</tr>
</tbody>
</table>
<h4 id="return-value-16">Return value</h4>
<p>The retrieved value.</p>
<h1 id="getstringelem"><a name="GetStringElem"></a>GetStringElem</h1>
<p>Extracts a single BSTR element from a safe array of unicode strings.</p>
<pre><code>FUNCTION GetStringElem (BYVAL iElem AS ULONG) AS BSTR
</code></pre>
<table>
<thead>
<tr class="header">
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><em>iElem</em></td>
<td>The index of the element of the array.</td>
</tr>
</tbody>
</table>
<h4 id="return-value-17">Return value</h4>
<p>The retrieved value.</p>
<h1 id="getulongelem"><a name="GetULongElem"></a>GetULongElem</h1>
<p>Extracts a single ULONG element from a safe array of unsigned longs.</p>
<pre><code>FUNCTION GetULongElem (BYVAL iElem AS ULONG) AS ULONG
</code></pre>
<table>
<thead>
<tr class="header">
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><em>iElem</em></td>
<td>The index of the element of the array.</td>
</tr>
</tbody>
</table>
<h4 id="return-value-18">Return value</h4>
<p>The retrieved value.</p>
<h1 id="getulongintelem"><a name="GetULongIntElem"></a>GetULongIntElem</h1>
<p>Extracts a single ULONGINT element from a safe array of unsigned long integers.</p>
<pre><code>FUNCTION GetULongIntElem (BYVAL iElem AS ULONG) AS ULONGINT
</code></pre>
<table>
<thead>
<tr class="header">
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><em>iElem</em></td>
<td>The index of the element of the array.</td>
</tr>
</tbody>
</table>
<h4 id="return-value-19">Return value</h4>
<p>The retrieved value.</p>
<h1 id="getushortelem"><a name="GetUShortElem"></a>GetUShortElem</h1>
<p>Extracts a single USHORT element from a safe array of unsigned shorts.</p>
<pre><code>FUNCTION GetUShortElem (BYVAL iElem AS ULONG) AS USHORT
</code></pre>
<table>
<thead>
<tr class="header">
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><em>iElem</em></td>
<td>The index of the element of the array.</td>
</tr>
</tbody>
</table>
<h4 id="return-value-20">Return value</h4>
<p>The retrieved value.</p>
<h1 id="getvariantelem"><a name="GetVariantElem"></a>GetVariantElem</h1>
<p>Extracts a single Variant element from a safe array of variants.</p>
<pre><code>FUNCTION GetVariantElem (BYVAL iElem AS ULONG) AS CVAR
</code></pre>
<table>
<thead>
<tr class="header">
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><em>iElem</em></td>
<td>The index of the element of the array.</td>
</tr>
</tbody>
</table>
<h4 id="return-value-21">Return value</h4>
<p>The retrieved value.</p>
<h1 id="put"><a name="Put"></a>Put</h1>
<p>Assigns values to a CVAR.</p>
<pre><code>SUB Put (BYREF wsz AS WSTRING)
SUB Put (BYREF cws AS CWSTR)
SUB Put (BYREF cbs AS CBSTR)
FUNCTION Put (BYREF cv AS CVAR) AS HRESULT
FUNCTION Put (BYVAL v AS VARIANT) AS HRESULT
FUNCTION Put (BYVAL pvar AS VARIANT PTR) AS HRESULT
FUNCTION Put (BYREF pDisp AS IDispatch PTR, BYVAL fAddRef AS BOOLEAN = FALSE) AS HRESULT
FUNCTION Put (BYREF pUnk AS IUnknown PTR, BYVAL fAddRef AS BOOLEAN = FALSE) AS HRESULT
SUB Put (BYVAL _value AS LONGINT, BYVAL _vType AS WORD = VT_I4)
SUB Put (BYVAL _value AS DOUBLE, BYVAL _vType AS WORD = VT_R8)
SUB Put (BYVAL _value AS LONGINT, BYREF strType AS STRING)
SUB Put (BYVAL _value AS DOUBLE, BYREF strType AS STRING)
SUB Put (BYVAL _pv AS ANY PTR, BYVAL _vType AS WORD)
SUB Put (BYVAL _pv AS ANY PTR, BYREF strType AS STRING)
</code></pre>
<table>
<thead>
<tr class="header">
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><em>wsz</em></td>
<td>An unicode string. You can also pass a Free Basic ansi string or a string literal.</td>
</tr>
<tr class="even">
<td><em>cws</em></td>
<td>A CWSTR variable.</td>
</tr>
<tr class="odd">
<td><em>cbs</em></td>
<td>A CBSTR variable.</td>
</tr>
<tr class="even">
<td><em>cv</em></td>
<td>A CVAR variable.</td>
</tr>
<tr class="odd">
<td><em>v</em></td>
<td>A VARIANT variable.</td>
</tr>
<tr class="even">
<td><em>v</em></td>
<td>A VARIANT variable.</td>
</tr>
<tr class="odd">
<td><em>pvar</em></td>
<td>Pointer to a VARIANT variable.</td>
</tr>
<tr class="even">
<td><em>pDisp</em></td>
<td>Pointer to a DISPATCH interface.</td>
</tr>
<tr class="odd">
<td><em>pUnk</em></td>
<td>Pointer to a UNKNOWN interface.</td>
</tr>
<tr class="even">
<td><em>_pv</em></td>
<td>Pointer to a variable. This will create a VT_BYREF variant of the specified type.</td>
</tr>
<tr class="odd">
<td><em>_vtype</em></td>
<td>The variant type, e.g. VT_I4, VT_UI4.</td>
</tr>
<tr class="even">
<td><em>strType</em></td>
<td>The variant type as a string: &quot;BOOL&quot;, &quot;BYTE&quot;, &quot;UBYTE&quot;, &quot;SHORT&quot;, &quot;USHORT, &quot;INT&quot;, UINT&quot;, &quot;LONG&quot;, &quot;ULONG&quot;, &quot;LONGINT&quot;, &quot;SINGLE, &quot;DOUBLE&quot;, &quot;NULL&quot;.</td>
</tr>
<tr class="odd">
<td><em>fAddRef</em></td>
<td>TRUE or FALSE. If TRUE, increases the reference count of the interface.</td>
</tr>
</tbody>
</table>
<h1 id="putnull"><a name="PutNull"></a>PutNull</h1>
<p>Assigns a null value to the CVAR.</p>
<pre><code>SUB PutNull
</code></pre>
<h1 id="putbool"><a name="PutBool"></a>PutBool</h1>
<p>Assigns a boolean value to the CVAR.</p>
<pre><code>SUB PutBool (BYVAL _value AS BOOL)
</code></pre>
<h1 id="putboolean"><a name="PutBoolean"></a>PutBoolean</h1>
<p>Assigns a boolean value to the CVAR.</p>
<pre><code>SUB PutBoolean (BYVAL _value AS BOOLEAN)
</code></pre>
<h1 id="putbyte"><a name="PutByte"></a>PutByte</h1>
<p>Assigns a byte value to the CVAR.</p>
<pre><code>SUB PutByte (BYVAL _value AS BYTE)
</code></pre>
<h1 id="putubyte"><a name="PutUByte"></a>PutUByte</h1>
<p>Assigns an unsigned ubyte value to the CVAR.</p>
<pre><code>SUB PutUByte (BYVAL _value AS UBYTE)
</code></pre>
<h1 id="putshort"><a name="PutShort"></a>PutShort</h1>
<p>Assigns a short integer value to the CVAR.</p>
<pre><code>SUB PutShort (BYVAL _value AS SHORT)
</code></pre>
<h1 id="putushort"><a name="PutUShort"></a>PutUShort</h1>
<p>Assigns an unsigned short integer value to the CVAR.</p>
<pre><code>SUB PutUShort (BYVAL _value AS USHORT)
</code></pre>
<h1 id="putint"><a name="PutInt"></a>PutInt</h1>
<p>Assigns an INT_ (long) value to the CVAR.</p>
<pre><code>SUB PutInt (BYVAL _value AS INT_)
</code></pre>
<h3 id="remark-2">Remark</h3>
<p>Don't confuse an INT_ (LONG) with the Free Basic INTEGER data type.</p>
<h1 id="putuint"><a name="PutUInt"></a>PutUInt</h1>
<p>Assigns an UINT (unsigned long) value to the CVAR.</p>
<pre><code>SUB PutUInt (BYVAL _value AS UINT)
</code></pre>
<h3 id="remark-3">Remark</h3>
<p>Don't confuse an UINT (ULONG) with the Free Basic UINTEGER data type.</p>
<h1 id="putlong"><a name="PutLong"></a>PutLong</h1>
<p>Assigns a LONG value to the CVAR.</p>
<pre><code>SUB PutLong (BYVAL _value AS LONG)
</code></pre>
<h1 id="putulong"><a name="PutULong"></a>PutULong</h1>
<p>Assigns a ULONG value to the CVAR.</p>
<pre><code>SUB PutULong (BYVAL _value AS ULONG)
</code></pre>
<h1 id="putlongint"><a name="PutLongInt"></a>PutLongInt</h1>
<p>Assigns a LONGINT value to the CVAR.</p>
<pre><code>SUB PutULong (BYVAL _value AS LONGINT)
</code></pre>
<h1 id="putulongint"><a name="PutULongInt"></a>PutULongInt</h1>
<p>Assigns a ULONGINT value to the CVAR.</p>
<pre><code>SUB PutULongInt (BYVAL _value AS ULONGINT)
</code></pre>
<h1 id="putsingle"><a name="PutSingle"></a>PutSingle</h1>
<p>Assigns a SINGLE value to the CVAR.</p>
<pre><code>SUB PutSingle (BYVAL _value AS SINGLE)
</code></pre>
<h1 id="putfloat"><a name="PutFloat"></a>PutFloat</h1>
<p>Assigns a SINGLE value to the CVAR.</p>
<pre><code>SUB PutFloat (BYVAL _value AS SINGLE)
</code></pre>
<h1 id="putdouble"><a name="PutDouble"></a>PutDouble</h1>
<p>Assigns a DOUBLE value to the CVAR.</p>
<pre><code>SUB PutDouble (BYVAL _value AS DOUBLE)
</code></pre>
<h1 id="putbooleanarray"><a name="PutBooleanArray"></a>PutBooleanArray</h1>
<p>Initializes CVAR from an array of Boolean values.</p>
<pre><code>FUNCTION PutBooleanArray (BYVAL prgf AS WINBOOL PTR, BYVAL cElems AS ULONG) AS HRESULT
</code></pre>
<table>
<thead>
<tr class="header">
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><em>prgf</em></td>
<td>Pointer to source array of Boolean values.</td>
</tr>
<tr class="even">
<td><em>cElems</em></td>
<td>The number of elements in the array.</td>
</tr>
</tbody>
</table>
<h4 id="return-value-22">Return value</h4>
<p>If this function succeeds, it returns S_OK (0). Otherwise, it returns an HRESULT error code.</p>
<h4 id="remarks-1">Remarks</h4>
<p>Creates a VT_ARRAY OR VT_BOOL variant.</p>
<h1 id="putshortarray"><a name="PutShortArray"></a>PutShortArray</h1>
<p>Initializes CVAR from an array of signed 16-bit integer values.</p>
<pre><code>FUNCTION PutShortArray (BYVAL prgf AS SHORT PTR, BYVAL cElems AS ULONG) AS HRESULT
</code></pre>
<table>
<thead>
<tr class="header">
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><em>prgf</em></td>
<td>Pointer to source array of SHORT values.</td>
</tr>
<tr class="even">
<td><em>cElems</em></td>
<td>The number of elements in the array.</td>
</tr>
</tbody>
</table>
<h4 id="return-value-23">Return value</h4>
<p>If this function succeeds, it returns S_OK (0). Otherwise, it returns an HRESULT error code.</p>
<h4 id="remarks-2">Remarks</h4>
<p>Creates a VT_ARRAY OR VT_I2 variant.</p>
<h1 id="putushortarray"><a name="PutUShortArray"></a>PutUshortArray</h1>
<p>Initializes CVAR from an array of 16-bit unsigned integer values.</p>
<pre><code>FUNCTION PutUshortArray (BYVAL prgf AS USHORT PTR, BYVAL cElems AS ULONG) AS HRESULT
</code></pre>
<table>
<thead>
<tr class="header">
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><em>prgf</em></td>
<td>Pointer to source array of USHORT values.</td>
</tr>
<tr class="even">
<td><em>cElems</em></td>
<td>The number of elements in the array.</td>
</tr>
</tbody>
</table>
<h4 id="return-value-24">Return value</h4>
<p>If this function succeeds, it returns S_OK (0). Otherwise, it returns an HRESULT error code.</p>
<h4 id="remarks-3">Remarks</h4>
<p>Creates a VT_ARRAY OR VT_UI2 variant.</p>
<h1 id="putlongarray"><a name="PutLongArray"></a>PutLongArray</h1>
<p>Initializes CVAR from an array of signed 32-bit integer values.</p>
<pre><code>FUNCTION PutLongArray (BYVAL prgf AS LONG PTR, BYVAL cElems AS ULONG) AS HRESULT
</code></pre>
<table>
<thead>
<tr class="header">
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><em>prgf</em></td>
<td>Pointer to source array of LONG values.</td>
</tr>
<tr class="even">
<td><em>cElems</em></td>
<td>The number of elements in the array.</td>
</tr>
</tbody>
</table>
<h4 id="return-value-25">Return value</h4>
<p>If this function succeeds, it returns S_OK (0). Otherwise, it returns an HRESULT error code.</p>
<h4 id="remarks-4">Remarks</h4>
<p>Creates a VT_ARRAY OR VT_I4 variant.</p>
<h1 id="putulongarray"><a name="PutULongArray"></a>PutULongArray</h1>
<p>Initializes CVAR from an array of 32-bit unsigned integer values.</p>
<pre><code>FUNCTION PutULongArray (BYVAL prgf AS ULONG PTR, BYVAL cElems AS ULONG) AS HRESULT
</code></pre>
<table>
<thead>
<tr class="header">
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><em>prgf</em></td>
<td>Pointer to source array of ULONG values.</td>
</tr>
<tr class="even">
<td><em>cElems</em></td>
<td>The number of elements in the array.</td>
</tr>
</tbody>
</table>
<h4 id="return-value-26">Return value</h4>
<p>If this function succeeds, it returns S_OK (0). Otherwise, it returns an HRESULT error code.</p>
<h4 id="remarks-5">Remarks</h4>
<p>Creates a VT_ARRAY OR VT_UI4 variant.</p>
<h1 id="putlongintarray"><a name="PutLongIntArray"></a>PutLongIntArray</h1>
<p>Initializes CVAR from an array of signed 64-bit integer values.</p>
<pre><code>FUNCTION PutLongIntArray (BYVAL prgf AS LONGINT PTR, BYVAL cElems AS ULONG) AS HRESULT
</code></pre>
<table>
<thead>
<tr class="header">
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><em>prgf</em></td>
<td>Pointer to source array of LONGINT values.</td>
</tr>
<tr class="even">
<td><em>cElems</em></td>
<td>The number of elements in the array.</td>
</tr>
</tbody>
</table>
<h4 id="return-value-27">Return value</h4>
<p>If this function succeeds, it returns S_OK (0). Otherwise, it returns an HRESULT error code.</p>
<h4 id="remarks-6">Remarks</h4>
<p>Creates a VT_ARRAY OR VT_I8 variant.</p>
<h1 id="putulongintarray"><a name="PutULongIntArray"></a>PutULongIntArray</h1>
<p>Initializes CVAR from an array of unsigned 64-bit integer values.</p>
<pre><code>FUNCTION PutULongIntArray (BYVAL prgf AS ULONGINT PTR, BYVAL cElems AS ULONG) AS HRESULT
</code></pre>
<table>
<thead>
<tr class="header">
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><em>prgf</em></td>
<td>Pointer to source array of ULONGINT values.</td>
</tr>
<tr class="even">
<td><em>cElems</em></td>
<td>The number of elements in the array.</td>
</tr>
</tbody>
</table>
<h4 id="return-value-28">Return value</h4>
<p>If this function succeeds, it returns S_OK (0). Otherwise, it returns an HRESULT error code.</p>
<h4 id="remarks-7">Remarks</h4>
<p>Creates a VT_ARRAY OR VT_UI8 variant.</p>
<h1 id="putdoublearray"><a name="PutDoubleArray"></a>PutDoubleArray</h1>
<p>Initializes CVAR from an array of unsigned 64-bit integer values.</p>
<pre><code>FUNCTION PutDoubleArray (BYVAL prgf AS DOUBLE PTR, BYVAL cElems AS ULONG) AS HRESULT
</code></pre>
<table>
<thead>
<tr class="header">
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><em>prgf</em></td>
<td>Pointer to source array of DOUBLE values.</td>
</tr>
<tr class="even">
<td><em>cElems</em></td>
<td>The number of elements in the array.</td>
</tr>
</tbody>
</table>
<h4 id="return-value-29">Return value</h4>
<p>If this function succeeds, it returns S_OK (0). Otherwise, it returns an HRESULT error code.</p>
<h4 id="remarks-8">Remarks</h4>
<p>Creates a VT_ARRAY OR VT_R8 variant.</p>
<h1 id="putstringarray"><a name="PutStringArray"></a>PutStringArray</h1>
<p>Initializes CVAR from an array of unicode strings.</p>
<pre><code>FUNCTION PutStringArray (BYVAL prgsz AS PCWSTR, BYVAL cElems AS ULONG) AS HRESULT
</code></pre>
<table>
<thead>
<tr class="header">
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><em>prgsz</em></td>
<td>Pointer to source array of unicode strings.</td>
</tr>
<tr class="even">
<td><em>cElems</em></td>
<td>The number of elements in the array.</td>
</tr>
</tbody>
</table>
<h4 id="return-value-30">Return value</h4>
<p>If this function succeeds, it returns S_OK (0). Otherwise, it returns an HRESULT error code.</p>
<h4 id="remarks-9">Remarks</h4>
<p>Creates a VT_ARRAY OR VT_BSTR variant.</p>
<h1 id="putbuffer"><a name="PutBuffer"></a>PutBuffer</h1>
<p>Initializes CVAR with the contents of a buffer.</p>
<pre><code>FUNCTION PutBuffer (BYVAL pv AS VOID PTR, BYVAL cb AS UINT) AS HRESULT
</code></pre>
<table>
<thead>
<tr class="header">
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><em>pv</em></td>
<td>Pointer to the source buffer.</td>
</tr>
<tr class="even">
<td><em>cb</em></td>
<td>The length of the buffer, in bytes.</td>
</tr>
</tbody>
</table>
<h4 id="return-value-31">Return value</h4>
<p>If this function succeeds, it returns S_OK (0). Otherwise, it returns an HRESULT error code.</p>
<h4 id="remarks-10">Remarks</h4>
<p>Creates a VT_ARRAY OR VT_UI1 variant.</p>
<h1 id="putdatestring"><a name="PutDateString"></a>PutDateString</h1>
<p>Initializes CVAR VT_DATE from a string.</p>
<pre><code>FUNCTION PutDateString (BYVAL pwszDate AS WSTRING PTR, BYVAL lcid AS LCID = 0, _
   BYVAL dwFlags AS ULONG = 0) AS HRESULT
</code></pre>
<table>
<thead>
<tr class="header">
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><em>pwszDate</em></td>
<td>The date value to convert, e.g. &quot;2018-08-20 19:42&quot;.</td>
</tr>
<tr class="even">
<td><em>lcid</em></td>
<td>The locale identifier.</td>
</tr>
<tr class="odd">
<td><em>dwFlags</em></td>
<td>One or more of the following flags.<br><em>LOCALE_NOUSEROVERRIDE</em> : Uses the system default locale settings, rather than custom locale settings.<br><em>VAR_CALENDAR_HIJRI</em> : If set then the Hijri calendar is used. Otherwise the calendar set in the control panel is used.<br><em>VAR_TIMEVALUEONLY</em> : Omits the date portion of a VT_DATE and returns only the time. Applies to conversions to or from dates.<br><em>VAR_DATEVALUEONLY</em> : Omits the time portion of a VT_DATE and returns only the date. Applies to conversions to or from dates.</td>
</tr>
</tbody>
</table>
<h4 id="return-value-32">Return value</h4>
<p>If this function succeeds, it returns S_OK (0). Otherwise, it returns an HRESULT error code.</p>
<h4 id="remarks-11">Remarks</h4>
<p>Creates a VT_DATE variant.</p>
<h1 id="putdec"><a name="PutDec"></a>PutDec</h1>
<p>Initializes CVAR with the contents of a DECIMAL structure.</p>
<pre><code>FUNCTION PutDec (BYCAL dec AS DECIMAL) AS HRESULT
</code></pre>
<table>
<thead>
<tr class="header">
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><em>dec</em></td>
<td>A DECIMAL structure.</td>
</tr>
</tbody>
</table>
<h4 id="return-value-33">Return value</h4>
<p>If this function succeeds, it returns S_OK (0). Otherwise, it returns an HRESULT error code.</p>
<h4 id="remarks-12">Remarks</h4>
<p>Creates a VT_DECIMAL OR VT_BYREF variant.</p>
<h1 id="putdecfromcy"><a name="PutDecFromCY"></a>PutDecFromCY</h1>
<p>Converts a currency value to a variant of type VT_DECIMAL.</p>
<pre><code>FUNCTION PutDecFromCY (BYVAL cyIn AS CY) AS HRESULT
</code></pre>
<table>
<thead>
<tr class="header">
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><em>cyIn</em></td>
<td>The currency value to convert.</td>
</tr>
</tbody>
</table>
<h4 id="return-value-34">Return value</h4>
<p>This function can return one of these values.</p>
<table>
<thead>
<tr class="header">
<th>Value</th>
<th>Meaning</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><em>S_OK</em></td>
<td>Success.</td>
</tr>
<tr class="even">
<td><em>DISP_E_TYPEMISMATCH</em></td>
<td>The argument could not be coerced to the specified type.</td>
</tr>
<tr class="odd">
<td><em>E_INVALIDARG</em></td>
<td>One of the arguments is not valid.</td>
</tr>
<tr class="even">
<td><em>E_OUTOFMEMORY</em></td>
<td>Insufficient memory to complete the operation.</td>
</tr>
</tbody>
</table>
<h4 id="remarks-13">Remarks</h4>
<p>Creates a VT_DECIMAL variant.</p>
<h1 id="putdecfromdouble"><a name="PutDecFromDouble"></a>PutDecFromDouble</h1>
<p>Converts a double value to a variant of type VT_DECIMAL.</p>
<pre><code>FUNCTION PutDecFromDouble (BYVAL dbIn AS DOUBLE) AS HRESULT
</code></pre>
<table>
<thead>
<tr class="header">
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><em>dbIn</em></td>
<td>The DOUBLE value to convert.</td>
</tr>
</tbody>
</table>
<h4 id="return-value-35">Return value</h4>
<p>This function can return one of these values.</p>
<table>
<thead>
<tr class="header">
<th>Value</th>
<th>Meaning</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><em>S_OK</em></td>
<td>Success.</td>
</tr>
<tr class="even">
<td><em>DISP_E_TYPEMISMATCH</em></td>
<td>The argument could not be coerced to the specified type.</td>
</tr>
<tr class="odd">
<td><em>E_INVALIDARG</em></td>
<td>One of the arguments is not valid.</td>
</tr>
<tr class="even">
<td><em>E_OUTOFMEMORY</em></td>
<td>Insufficient memory to complete the operation.</td>
</tr>
</tbody>
</table>
<h4 id="remarks-14">Remarks</h4>
<p>Creates a VT_DECIMAL variant.</p>
<h1 id="putdecfromstr"><a name="PutDecFromStr"></a>PutDecFromStr</h1>
<p>Initializes CVAR as VT_DECIMAL from a string.</p>
<pre><code>FUNCTION PutDecFromStr (BYVAL pwszIn AS WSTRING PTR, BYVAL lcid AS LCID = 0, _
   BYVAL dwFlags AS ULONG = 0) AS HRESULT
</code></pre>
<table>
<thead>
<tr class="header">
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><em>pwszIn</em></td>
<td>The string value to convert.</td>
</tr>
<tr class="even">
<td><em>lcid</em></td>
<td>The locale identifier.</td>
</tr>
<tr class="odd">
<td><em>dwFlags</em></td>
<td>One or more of the following flags.<br><em>LOCALE_NOUSEROVERRIDE</em> : Uses the system default locale settings, rather than custom locale settings.<br><em>VAR_TIMEVALUEONLY</em> : Omits the date portion of a VT_DATE and returns only the time. Applies to conversions to or from dates.<br><em>VAR_DATEVALUEONLY</em> : Omits the time portion of a VT_DATE and returns only the date. Applies to conversions to or from dates.</td>
</tr>
</tbody>
</table>
<h4 id="return-value-36">Return value</h4>
<p>This function can return one of these values.</p>
<table>
<thead>
<tr class="header">
<th>Value</th>
<th>Meaning</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><em>S_OK</em></td>
<td>Success.</td>
</tr>
<tr class="even">
<td><em>DISP_E_TYPEMISMATCH</em></td>
<td>The argument could not be coerced to the specified type.</td>
</tr>
<tr class="odd">
<td><em>E_INVALIDARG</em></td>
<td>One of the arguments is not valid.</td>
</tr>
<tr class="even">
<td><em>E_OUTOFMEMORY</em></td>
<td>Insufficient memory to complete the operation.</td>
</tr>
</tbody>
</table>
<h4 id="remarks-15">Remarks</h4>
<p>Creates a VT_DECIMAL variant.</p>
<h1 id="putfiletime"><a name="PutFileTime"></a>PutFileTime</h1>
<p>Initializes CVAR with the contents of a FILETIME structure.</p>
<pre><code>FUNCTION PutFileTime (BYVAL pft AS FILETIME PTR) AS HRESULT
</code></pre>
<table>
<thead>
<tr class="header">
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><em>pft</em></td>
<td>Pointer to a FILETIME structure.</td>
</tr>
</tbody>
</table>
<h4 id="return-value-37">Return value</h4>
<p>If this function succeeds, it returns S_OK (0). Otherwise, it returns an HRESULT error code.</p>
<h4 id="remarks-16">Remarks</h4>
<p>Creates a VT_DATE variant.</p>
<h1 id="putfiletimearray"><a name="PutFileTimeArray"></a>PutFileTimeArray</h1>
<p>Initializes CVAR with an array of FILETIME structures.</p>
<pre><code>FUNCTION PutFileTimeArray (BYVAL prgft AS FILETIME PTR, BYVAL cElems AS ULONG) AS HRESULT
</code></pre>
<table>
<thead>
<tr class="header">
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><em>prgft</em></td>
<td>Pointer to an array of FILETIME structures.</td>
</tr>
<tr class="even">
<td><em>cElems</em></td>
<td>The number of elements in the array pointed to by <em>prgft</em>.</td>
</tr>
</tbody>
</table>
<h4 id="return-value-38">Return value</h4>
<p>If this function succeeds, it returns S_OK (0). Otherwise, it returns an HRESULT error code.</p>
<h4 id="remarks-17">Remarks</h4>
<p>Creates a VT_ARRAY OR VT_DATE variant.</p>
<h1 id="putguid"><a name="PutGuid"></a>PutGuid</h1>
<p>Initializes CVAR from a GUID.</p>
<pre><code>FUNCTION PutGuid (BYVAL rguid AS GUID PTR) AS HRESULT
</code></pre>
<table>
<thead>
<tr class="header">
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><em>rguid</em></td>
<td>Reference to the source GUID.</td>
</tr>
</tbody>
</table>
<h4 id="return-value-39">Return value</h4>
<p>If this function succeeds, it returns S_OK (0). Otherwise, it returns an HRESULT error code.</p>
<h4 id="remarks-18">Remarks</h4>
<p>Creates a VT_ARRAY OR VT_UI1 variant.</p>
<h1 id="putpropvariant"><a name="PutPropVariant"></a>PutPropVariant</h1>
<p>Initializes CVAR from the contents of a PROPVARIANT structure.</p>
<pre><code>FUNCTION PutPropVariant (BYVAL pPropVar AS PROPVARIANT PTR) AS HRESULT
</code></pre>
<table>
<thead>
<tr class="header">
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><em>pPropVar</em></td>
<td>Pointer to a source PROPVARIANT structure.</td>
</tr>
</tbody>
</table>
<h4 id="return-value-40">Return value</h4>
<p>If this function succeeds, it returns S_OK (0). Otherwise, it returns an HRESULT error code.</p>
<h4 id="remarks-19">Remarks</h4>
<p>Normally, the data stored in the PROPVARIANT is copied to the VARIANT without a datatype change. However, in the following cases, there is no direct VARIANT support for the datatype, and they are converted as shown.</p>
<p>VT_BLOB, VT_STREAM<br> Converted to VT_UNKNOWN. The punkVal member will contain a pointer to an IStream that contains the source data.</p>
<p>VT_LPSTR, VT_LPWSTR, VT_CLSID<br> Converted to VT_BSTR,</p>
<p>VT_FILETIME<br> Converted to VT_DATE.</p>
<p>VT_VECTOR OR x<br> Converted to VT_ARRAY OR x</p>
<p>The following types cannot be converted with this function.</p>
<p>VT_STORAGE<br> VT_BLOB_OBJECT<br> VT_STREAMED_OBJECT<br> VT_STORED_OBJECT<br> VT_CF<br> VT_VECTOR OR VT_CF</p>
<h1 id="putrecord"><a name="PutRecord"></a>PutRecord</h1>
<p>Initializes CVAR with a reference to an UDT.</p>
<pre><code>FUNCTION PutRecord (BYVAL pIRecordInfo AS IRecordInfo PTR, BYVAL pRec AS VOID PTR) AS HRESULT
</code></pre>
<table>
<thead>
<tr class="header">
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><em>pIRecordInfo</em></td>
<td>Pointer to the IRecordInfo interface.</td>
</tr>
<tr class="even">
<td><em>pRec</em></td>
<td>Pointer to the UDT.</td>
</tr>
</tbody>
</table>
<h4 id="return-value-41">Return value</h4>
<p>If this function succeeds, it returns S_OK (0). Otherwise, it returns an HRESULT error code.</p>
<h4 id="remarks-20">Remarks</h4>
<p>Creates a VT_RECORD variant.</p>
<h1 id="putref"><a name="PutRef"></a>PutRef</h1>
<p>Assigns a value by reference (a pointer to a variable).</p>
<pre><code>FUNCTION PutRef (BYVAL _pvar AS ANY PTR, BYVAL _vType AS WORD) AS HRESULT
FUNCTION PutRef (BYVAL _pvar AS ANY PTR, BYREF strType AS STRING) AS HRESULT
</code></pre>
<table>
<thead>
<tr class="header">
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><em>_pvar</em></td>
<td>Pointer to a variable.</td>
</tr>
<tr class="even">
<td><em>_vType</em></td>
<td>Type of the variant: VT_BOOL, VT_I1, VT_UI1, VT_I2, VT_UI2, VT_INT, VT_UINT, VT_I4, VT_UI4, VT_I8, VT_UI8, VT_R4, VT_R8, VT_BSTR, VT_UNKNOWN, VT_DISPATCH, VT_DECIMAL, VT_CY, VT_DATE, VT_VARIANT, VT_SAFEARRAY, VT_ERROR.</td>
</tr>
<tr class="odd">
<td><em>strType</em></td>
<td>Type of the variant: &quot;BOOL&quot;, &quot;BYTE&quot;, &quot;UBYTE&quot;, &quot;SHORT&quot;, &quot;USHORT&quot;, &quot;INT&quot;, &quot;UINT&quot;, &quot;LONG&quot;, &quot;ULONG&quot;, &quot;LONGINT&quot;, &quot;ULONGINT&quot;, &quot;SINGLE&quot;, &quot;DOUBLE&quot;, &quot;BSTR&quot;, &quot;UNKNOWN&quot;, &quot;DISPATCH&quot;, &quot;DECIMAL&quot;, &quot;CY&quot;, &quot;DATE&quot;, &quot;VARIANT&quot;, &quot;SAFEARRAY&quot;, &quot;ERROR&quot;.</td>
</tr>
</tbody>
</table>
<h4 id="return-value-42">Return value</h4>
<p>If this function succeeds, it returns S_OK (0). Otherwise, it returns an HRESULT error code.</p>
<h4 id="remarks-21">Remarks</h4>
<p>Creates a VT_BYREF variant of the sepecified type.</p>
<h1 id="putresource"><a name="PutResource"></a>PutResource</h1>
<p>Initializes the CVAR based on a string resource imbedded in an executable file.</p>
<pre><code>FUNCTION PutResource (BYVAL hinst AS HINSTANCE, BYVAL id AS UINT) AS HRESULT
</code></pre>
<table>
<thead>
<tr class="header">
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><em>hinst</em></td>
<td>The instance handle.</td>
</tr>
<tr class="even">
<td><em>id</em></td>
<td>Integer identifier of the string to be loaded.</td>
</tr>
</tbody>
</table>
<h4 id="return-value-43">Return value</h4>
<p>If this function succeeds, it returns S_OK (0). Otherwise, it returns an HRESULT error code.</p>
<h4 id="remarks-22">Remarks</h4>
<p>Creates a VT_BSTR variant. If the resource does not exist, this function initializes the VARIANT as VT_EMPTY and returns a failure code.</p>
<h1 id="putsafearray"><a name="PutSafeArray"></a>PutSafeArray</h1>
<p>Initializes CVAR from a safe array.</p>
<pre><code>FUNCTION PutSafeArray (BYVAL parray AS SAFEARRAY PTR) AS HRESULT
</code></pre>
<table>
<thead>
<tr class="header">
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><em>parray</em></td>
<td>Pointer to safe array.</td>
</tr>
</tbody>
</table>
<h4 id="return-value-44">Return value</h4>
<p>If this function succeeds, it returns S_OK (0). Otherwise, it returns an HRESULT error code.</p>
<h4 id="remarks-23">Remarks</h4>
<p>Creates a VT_ARRAY variant.</p>
<h1 id="putstrret"><a name="PutStrRet"></a>PutStrRet</h1>
<p>Initializes CVAR with the string stored in a STRRET structure.</p>
<pre><code>FUNCTION PutStrRet (BYVAL pstrret AS STRRET PTR, BYVAL pidl AS PCUITEMID_CHILD) AS HRESULT
</code></pre>
<table>
<thead>
<tr class="header">
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><em>pstrret</em></td>
<td>Pointer to a STRRET structure.</td>
</tr>
<tr class="even">
<td><em>pidl</em></td>
<td>PIDL of the item whose details are being retrieved.</td>
</tr>
</tbody>
</table>
<h4 id="return-value-45">Return value</h4>
<p>If this function succeeds, it returns S_OK (0). Otherwise, it returns an HRESULT error code.</p>
<h4 id="remarks-24">Remarks</h4>
<p>Creates a VT_BSTR variant. This function frees the resources used for the STRRET contents.</p>
<h1 id="putsystemtime"><a name="PutSystemTime"></a>PutSystemTime</h1>
<p>Initializes CVAR with the contents of a SYSTEMTIME structure.</p>
<pre><code>FUNCTION PutSystemTime (BYVAL pst AS SYSTEMTIME PTR) AS HRESULT
</code></pre>
<table>
<thead>
<tr class="header">
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><em>pst</em></td>
<td>Pointer to a SYSTEMTIME structure.</td>
</tr>
</tbody>
</table>
<h4 id="return-value-46">Return value</h4>
<p>If this function succeeds, it returns S_OK (0). Otherwise, it returns an HRESULT error code.</p>
<h4 id="remarks-25">Remarks</h4>
<p>Creates a VT_DATE variant.</p>
<h1 id="pututf8"><a name="PutUtf8"></a>PutUtf8</h1>
<p>Initializes CVAR with the contents of an UTF-8 string.</p>
<pre><code>FUNCTION PutUtf8 (BYREF strUtf8 AS STRING) AS HRESULT
</code></pre>
<table>
<thead>
<tr class="header">
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><em>strUtf8</em></td>
<td>The UTF-8 encoded string.</td>
</tr>
</tbody>
</table>
<h4 id="return-value-47">Return value</h4>
<p>If this function succeeds, it returns S_OK (0). Otherwise, it returns an HRESULT error code.</p>
<h4 id="remarks-26">Remarks</h4>
<p>Creates a VT_BSTR variant.</p>
<h1 id="putvariantarrayelem"><a name="PutVariantArrayElem"></a>PutVariantArrayElem</h1>
<p>Initializes CVAR with a value stored in another VARIANT structure.</p>
<pre><code>FUNCTION PutVariantArrayElem (BYVAL pvarIn AS VARIANT PTR, BYVAL iElem AS ULONG) AS HRESULT
</code></pre>
<table>
<thead>
<tr class="header">
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><em>pvarIn</em></td>
<td>Reference to the source VARIANT structure.</td>
</tr>
<tr class="even">
<td><em>iElem</em></td>
<td>Index of one of the source VARIANT structure elements.</td>
</tr>
</tbody>
</table>
<h4 id="return-value-48">Return value</h4>
<p>If this function succeeds, it returns S_OK (0). Otherwise, it returns an HRESULT error code.</p>
<h4 id="remarks-27">Remarks</h4>
<p>This helper function works for VARIANT structures of the following types:</p>
<pre><code>VT_BSTR
VT_BOOL
VT_I2
VT_I4
VT_I8
VT_U12
VT_U14
VT_U18
VT_DATE
VT_ARRAY | (any one of VT_BSTR, VT_BOOL, VT_I2, VT_I4, VT_I8, VT_U12, VT_U14, VT_U18, VT_DATE)
</code></pre>
<p>Additional types may be supported in the future.</p>
<p>This function extracts a single value from the source VARIANT structure and uses that value to initialize the output VARIANT structure. The calling application must use VariantClear to free the VARIANT referred to by pvar when it is no longer needed.</p>
<p>If the source VARIANT is an array, <em>iElem</em> must be less than the number of elements in the array.</p>
<p>If the source VARIANT has a single value, <em>iElem</em> must be 0.</p>
<p>If the source VARIANT is empty, this function always returns an error code.</p>
<p>You can use <strong>GetElementCount</strong> to obtain the number of elements in the array or array.</p>
<h1 id="putvbdate"><a name="PutVbDate"></a>PutVbDate</h1>
<p>Initializes CVAR with the contents of a DATE value.</p>
<pre><code>FUNCTION PutVbDate (BYREF vbDate AS DATE_) AS HRESULT
</code></pre>
<table>
<thead>
<tr class="header">
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><em>vbDate</em></td>
<td>The DATE value.</td>
</tr>
</tbody>
</table>
<h4 id="return-value-49">Return value</h4>
<p>If this function succeeds, it returns S_OK (0). Otherwise, it returns an HRESULT error code.</p>
<h4 id="remarks-28">Remarks</h4>
<p>Creates a VT_DATE variant.</p>
<h1 id="tobooleanarray"><a name="ToBooleanArray"></a>ToBooleanArray</h1>
<p>Extracts an array of boolean values from CVAR.</p>
<pre><code>FUNCTION ToBooleanArray (BYVAL prgf AS WINBOOL PTR, BYVAL crgn AS ULONG) AS ULONG
</code></pre>
<table>
<thead>
<tr class="header">
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><em>prgf</em></td>
<td>Pointer to a buffer that contains <em>crgn</em> boolean values. When this function returns, the buffer has been initialized with elements extracted from the source VARIANT structure.</td>
</tr>
<tr class="even">
<td><em>crgn</em></td>
<td>The number of elements in the buffer pointed to by <em>prgf</em>.</td>
</tr>
</tbody>
</table>
<h4 id="return-value-50">Return value</h4>
<p>The count of WINBOOL elements extracted from the CVAR.</p>
<h4 id="remarks-29">Remarks</h4>
<p>This helper function is used when the calling application expects a VARIANT to hold an array that consists of a fixed number of boolean values.</p>
<p>If the source VARIANT is of type VT_ARRAY OR VT_BOOL, this function extracts up to <em>crgn</em> WINBOOL values and places them into the buffer pointed to by <em>prgf</em>. If the VARIANT contains more elements than will fit into the <em>prgf</em> buffer, this function returns 0.</p>
<h1 id="tobooleanarrayalloc"><a name="ToBooleanArrayAlloc"></a>ToBooleanArrayAlloc</h1>
<p>Extracts an array of boolean values from CVAR.</p>
<pre><code>FUNCTION ToBooleanArrayAlloc (BYVAL pprgf AS WINBOOL PTR PTR) AS ULONG
</code></pre>
<table>
<thead>
<tr class="header">
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><em>prgf</em></td>
<td>Pointer to a WINBOOL PTR variable that will recive a pointer to an array of WINBOOL values extracted from the source CVAR.</td>
</tr>
</tbody>
</table>
<h4 id="return-value-51">Return value</h4>
<p>The count of WINBOOL elements extracted from the CVAR.</p>
<h4 id="remarks-30">Remarks</h4>
<p>This helper function is used when the calling application expects a CVAR to hold an array of WINBOOL values.</p>
<p>If CVAR is of type VT_ARRAY OR VT_BOOL, this function extracts an array of WINBOOL values into a newly allocated array. The calling application is responsible for using <strong>CoTaskMemFree</strong> to release the array pointed to by <em>pprgf</em> when it is no longer needed.</p>
<h1 id="tobstr"><a name="ToBstr"></a>ToBstr</h1>
<p>Extracts the content of the underlying variant and returns it as a CBSTR.</p>
<pre><code>FUNCTION ToBstr () AS CBSTR
</code></pre>
<h4 id="return-value-52">Return value</h4>
<p>The contents of the variant as a CBSTR.</p>
<h4 id="example">Example</h4>
<pre><code>DIM cv AS CVAR = &quot;Test string&quot;
DIM cbs AS CBSTR = cv.ToBstr
</code></pre>
<h1 id="tobuffer"><a name="ToBuffer"></a>ToBuffer</h1>
<p>Extracts the contents of a CVAR of type VT_ARRRAY OR VT_UI1 to a buffer.</p>
<pre><code>FUNCTION ToBuffer (BYVAL pv AS VOID PTR, BYVAL cb AS UINT) AS HRESULT
</code></pre>
<table>
<thead>
<tr class="header">
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><em>pv</em></td>
<td>Pointer to a buffer of length <em>cb</em> bytes. When this function returns, contains the first <em>cb</em> bytes of the extracted buffer value.</td>
</tr>
<tr class="even">
<td><em>cb</em></td>
<td>The size of the <em>pv</em> buffer, in bytes. The buffer should be the same size as the data to be extracted, or smaller.</td>
</tr>
</tbody>
</table>
<h4 id="return-value-53">Return value</h4>
<p>Returns one of the following values:</p>
<table>
<thead>
<tr class="header">
<th>Value</th>
<th>Meaning</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><em>S_OK</em></td>
<td>Data successfully extracted.</td>
</tr>
<tr class="even">
<td><em>E_INVALIDARG</em></td>
<td>The VARIANT was not of type VT_ARRRAY OR VT_UI1.</td>
</tr>
<tr class="odd">
<td><em>E_FAIL</em></td>
<td>The VARIANT buffer value had fewer than cb bytes.</td>
</tr>
</tbody>
</table>
<h4 id="remarks-31">Remarks</h4>
<p>This function is used when the calling application expects a VARIANT to hold a buffer value. The calling application should check that the value has the expected length before it calls this function.</p>
<p>If CVAR has type VT_ARRAY OR VT_UI1, this function extracts the first <em>cb</em> bytes from the structure and places them in the buffer pointed to by <em>pv</em>.</p>
<p>If the stored value has fewer than <em>cb</em> bytes, then function fails and the buffer is not modified.</p>
<p>If the value has more than <em>cb</em> bytes, then function succeeds and truncates the value.</p>
<p>To retrieve the size of the array call <strong>GetElementCount</strong>.</p>
<h1 id="tobuffer-(string)"><a name="ToBufferString"></a>ToBuffer (STRING)</h1>
<p>Extracts the contents of a CVAR of type VT_ARRRAY OR VT_UI1 to a string used as a buffer.</p>
<pre><code>FUNCTION ToBuffer () AS STRING
</code></pre>
<h4 id="return-value-54">Return value</h4>
<p>A string with the contents of the array.</p>
<h1 id="todosdatetime"><a name="ToDosDateTime"></a>ToDosDateTime</h1>
<p>Extracts a date and time value in Microsoft MS-DOS format from a CVAR of type VT_DATE.</p>
<pre><code>FUNCTION ToDosDateTime (BYVAL pwDate AS USHORT PTR, BYVAL pwTime AS USHORT PTR) AS HRESULT
</code></pre>
<table>
<thead>
<tr class="header">
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><em>pwDate</em></td>
<td>When this function returns, contains the extracted USHORT that represents a MS-DOS date.</td>
</tr>
<tr class="even">
<td><em>pwTime</em></td>
<td>When this function returns, contains the extracted contains the extracted WORD that represents a MS-DOS time.</td>
</tr>
</tbody>
</table>
<h4 id="return-value-55">Return value</h4>
<p>If this function succeeds, it returns S_OK (0). Otherwise, it returns an HRESULT error code.</p>
<h4 id="remarks-32">Remarks</h4>
<p>This helper function is used when the calling application expects a CVAR to hold a datetime value.</p>
<p>If CVAR is of type VT_DATE, this function extracts the datetime value.</p>
<p>If CVAR is not of type VT_DATE, the function attempts to convert the value in the VARIANT structure into the right format. If a conversion is not possible, it returns a failure code.</p>
<h1 id="todoublearray"><a name="ToDoubleArray"></a>ToDoubleArray</h1>
<p>Extracts an array of DOUBLE values from CVAR.</p>
<pre><code>FUNCTION ToDoubleArray (BYVAL prgn AS DOUBLE PTR, BYVAL crgn AS ULONG) AS ULONG
</code></pre>
<table>
<thead>
<tr class="header">
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><em>prgn</em></td>
<td>Pointer to a buffer that contains crgn DOUBLE variables. When this function returns, the buffer has been initialized with DOUBLE elements extracted from CVAR.</td>
</tr>
<tr class="even">
<td><em>crgn</em></td>
<td>The number of elements in the buffer pointed to by <em>prgn</em>.</td>
</tr>
</tbody>
</table>
<h4 id="return-value-56">Return value</h4>
<p>This helper function is used when the calling application expects a VARIANT to hold an array that consists of a fixed number of DOUBLE values.</p>
<p>If the source VARIANT is of type VT_ARRAY OR VT_R8, this function extracts up to <em>crgn</em> DOUBLE values and places them into the buffer pointed to by <em>prgn</em>. If the VARIANT contains more elements than will fit into the <em>prgn</em> buffer, this function returns 0.</p>
<h1 id="todoublearrayalloc"><a name="ToDoubleArrayAlloc"></a>ToDoubleArrayAlloc</h1>
<p>Extracts an array of DOUBLE values from CVAR.</p>
<pre><code>FUNCTION ToDoubleArrayAlloc (BYVAL pprgn AS ULONGINT PTR PTR) AS ULONG
</code></pre>
<table>
<thead>
<tr class="header">
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><em>pprgf</em></td>
<td>Pointer to a DOUBLE PTR variable that will recive a pointer to an array of DOUBLE values extracted from the source CVAR.</td>
</tr>
</tbody>
</table>
<h4 id="return-value-57">Return value</h4>
<p>The count of DOUBLE elements extracted from the CVAR.</p>
<h4 id="remarks-33">Remarks</h4>
<p>This helper function is used when the calling application expects a CVAR to hold an array of DOUBLE values.</p>
<p>If CVAR is of type VT_ARRAY OR VT_R8, this function extracts an array of DOUBLE values into a newly allocated array. The calling application is responsible for using <strong>CoTaskMemFree</strong> to release the array pointed to by <em>pprgn</em> when it is no longer neede</p>
<h1 id="tofiletime"><a name="ToFileTime"></a>ToFileTime</h1>
<p>Returns the contents of a CVAR of type VT_DATE as a FILETIME structure.</p>
<pre><code>FUNCTION ToFileTime (BYVAL stfOut AS AFX_PSTIME_FLAGS) AS FILETIME
</code></pre>
<table>
<thead>
<tr class="header">
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><em>stfOut</em></td>
<td>Specifies one of the following time flags:<br><em>PSTF_UTC (0)</em> : Indicates coordinated universal time.<br><em>PSTF_LOCAL (1)</em> : Indicates local time.</td>
</tr>
</tbody>
</table>
<h4 id="return-value-58">Return value</h4>
<p>A FILETIME structure.</p>
<h1 id="toguid"><a name="ToGuid"></a>ToGuid</h1>
<p>Returns the contents of a CVAR containing a GUID string as a GUID structure.</p>
<pre><code>FUNCTION ToGuid () AS GUID
</code></pre>
<h4 id="return-value-59">Return value</h4>
<p>Returns the contents of a CVAR containing a GUID string as an unicode GUID string.</p>
<h1 id="toguidbstr"><a name="ToGuidBStr"></a>ToGuidBStr</h1>
<p>Returns the contents of a CVAR containing a GUID string as an unicode GUID string.</p>
<pre><code>FUNCTION ToGuidBStr () AS CBSTR
</code></pre>
<h4 id="return-value-60">Return value</h4>
<p>A GUID string.</p>
<h1 id="toguidstr"><a name="ToGuidStr"></a>ToGuidStr</h1>
<p>Returns the contents of a CVAR containing a GUID string as an unicode GUID string.</p>
<pre><code>FUNCTION ToGuidStr () AS CWSTR
</code></pre>
<h4 id="return-value-61">Return value</h4>
<p>A GUID string.</p>
<h1 id="toguidwstr"><a name="ToGuidWStr"></a>ToGuidWStr</h1>
<p>Returns the contents of a CVAR containing a GUID string as an unicode GUID string.</p>
<pre><code>FUNCTION ToGuidWStr () AS CWSTR
</code></pre>
<h4 id="return-value-62">Return value</h4>
<p>A GUID string.</p>
<h1 id="tolongarray"><a name="ToLongArray"></a>ToLongArray</h1>
<p>Extracts an array of LONG values from CVAR.</p>
<pre><code>FUNCTION ToLongArray (BYVAL prgn AS LONG PTR, BYVAL crgn AS ULONG) AS ULONG
</code></pre>
<table>
<thead>
<tr class="header">
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><em>prgn</em></td>
<td>Pointer to a buffer that contains <em>crgn</em> LONG variables. When this function returns, the buffer has been initialized with Int32 elements extracted from CVAR.</td>
</tr>
<tr class="even">
<td><em>crgn</em></td>
<td>The number of elements in the buffer pointed to by <em>prgn</em>.</td>
</tr>
</tbody>
</table>
<h4 id="return-value-63">Return value</h4>
<p>This helper function is used when the calling application expects a VARIANT to hold an array that consists of a fixed number of Int32 values.</p>
<p>If the source VARIANT is of type VT_ARRAY OR VT_I4, this function extracts up to <em>crgn</em> Int32 values and places them into the buffer pointed to by <em>prgn</em>. If the VARIANT contains more elements than will fit into the <em>prgn</em> buffer, this function returns 0.</p>
<h1 id="tolongarrayalloc"><a name="ToLongArrayAlloc"></a>ToLongArrayAlloc</h1>
<p>Extracts an array of LONG values from CVAR.</p>
<pre><code>FUNCTION ToLongArrayAlloc (BYVAL pprgn AS LONG PTR PTR) AS ULONG
</code></pre>
<table>
<thead>
<tr class="header">
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><em>pprgn</em></td>
<td>Pointer to a LONG PTR variable that will recive a pointer to an array of LONG values extracted from the source CVAR.</td>
</tr>
</tbody>
</table>
<h4 id="return-value-64">Return value</h4>
<p>The count of LONG elements extracted from the CVAR.</p>
<h4 id="remarks-34">Remarks</h4>
<p>This helper function is used when the calling application expects a CVAR to hold an array of LONG values.</p>
<p>If CVAR is of type VT_ARRAY OR VT_I4, this function extracts an array of LONG values into a newly allocated array. The calling application is responsible for using <strong>CoTaskMemFree</strong> to release the array pointed to by <em>pprgn</em> when it is no longer needed.</p>
<h1 id="tolongintarray"><a name="ToLongIntArray"></a>ToLongIntArray</h1>
<p>Extracts an array of LONGINT values from CVAR.</p>
<pre><code>FUNCTION ToLongIntArray (BYVAL prgn AS LONGINT PTR, BYVAL crgn AS ULONG) AS ULONG
</code></pre>
<table>
<thead>
<tr class="header">
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><em>prgn</em></td>
<td>Pointer to a buffer that contains <em>crgn</em> LONGINT variables. When this function returns, the buffer has been initialized with Int64 elements extracted from CVAR.</td>
</tr>
<tr class="even">
<td><em>crgn</em></td>
<td>The number of elements in the buffer pointed to by <em>prgn</em>.</td>
</tr>
</tbody>
</table>
<h4 id="return-value-65">Return value</h4>
<p>This helper function is used when the calling application expects a VARIANT to hold an array that consists of a fixed number of Int64 values.</p>
<p>If the source VARIANT is of type VT_ARRAY OR VT_UI4, this function extracts up to <em>crgn</em> Int64 values and places them into the buffer pointed to by <em>prgn</em>. If the VARIANT contains more elements than will fit into the <em>prgn</em> buffer, this function returns 0.</p>
<h1 id="tolongintarrayalloc"><a name="ToLongIntArrayAlloc"></a>ToLongIntArrayAlloc</h1>
<p>Extracts an array of LONGINT values from CVAR.</p>
<pre><code>FUNCTION ToLongIntArrayAlloc (BYVAL pprgn AS LONGINT PTR PTR) AS ULONG
</code></pre>
<table>
<thead>
<tr class="header">
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><em>pprgn</em></td>
<td>Pointer to a LONGINT PTR variable that will recive a pointer to an array of LONGINT values extracted from the source CVAR.</td>
</tr>
</tbody>
</table>
<p>|</p>
<h4 id="return-value-66">Return value</h4>
<p>The count of LONGINT elements extracted from the CVAR.</p>
<h4 id="remarks-35">Remarks</h4>
<p>This helper function is used when the calling application expects a CVAR to hold an array of LONGINT values.</p>
<p>If CVAR is of type VT_ARRAY OR VT_I8, this function extracts an array of LONGINT values into a newly allocated array. The calling application is responsible for using <strong>CoTaskMemFree</strong> to release the array pointed to by <em>pprgn</em> when it is no longer needed.</p>
<h1 id="toshortarray"><a name="ToShortArray"></a>ToShortArray</h1>
<p>Extracts an array of Int16 values from CVAR.</p>
<pre><code>FUNCTION ToShortArray (BYVAL prgn AS SHORT PTR, BYVAL crgn AS ULONG) AS ULONG
</code></pre>
<table>
<thead>
<tr class="header">
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><em>prgn</em></td>
<td>Pointer to a buffer that contains <em>crgn</em> Int16 variables. When this function returns, the buffer has been initialized with Int16 elements extracted from CVAR.</td>
</tr>
<tr class="even">
<td><em>crgn</em></td>
<td>The number of elements in the buffer pointed to by <em>prgn</em>.</td>
</tr>
</tbody>
</table>
<h4 id="return-value-67">Return value</h4>
<p>The count of Int16 elements extracted from the CVAR.</p>
<h4 id="remarks-36">Remarks</h4>
<p>This helper function is used when the calling application expects a VARIANT to hold an array that consists of a fixed number of Int16 values.</p>
<p>If the source VARIANT is of type VT_ARRAY OR VT_I2, this function extracts up to <em>crgn</em> Int16 values and places them into the buffer pointed to by <em>prgn</em>. If the VARIANT contains more elements than will fit into the <em>prgn</em> buffer, this function returns 0.</p>
<h1 id="toshortarrayalloc"><a name="ToShortArrayAlloc"></a>ToShortArrayAlloc</h1>
<p>Extracts an array of SHORT values from CVAR.</p>
<pre><code>FUNCTION ToShortArrayAlloc (BYVAL pprgn AS SHORT PTR PTR) AS ULONG
</code></pre>
<table>
<thead>
<tr class="header">
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><em>pprgn</em></td>
<td>Pointer to a SHORT PTR variable that will recive a pointer to an array of SHORT values extracted from the source CVAR.</td>
</tr>
</tbody>
</table>
<h4 id="return-value-68">Return value</h4>
<p>The count of SHORT elements extracted from the CVAR.</p>
<h4 id="remarks-37">Remarks</h4>
<p>This helper function is used when the calling application expects a CVAR to hold an array of SHORT values.</p>
<p>If CVAR is of type VT_ARRAY OR VT_I2, this function extracts an array of SHORT values into a newly allocated array. The calling application is responsible for using <strong>CoTaskMemFree</strong> to release the array pointed to by <em>pprgn</em> when it is no longer needed.</p>
<h1 id="tostr"><a name="ToStr"></a>ToStr</h1>
<p>Extracts the content of the underlying variant and returns it as a CWSTR.</p>
<pre><code>FUNCTION ToStr () AS CWSTR
</code></pre>
<h4 id="return-value-69">Return value</h4>
<p>The contents of the variant as a CWSTR.</p>
<h4 id="example-1">Example</h4>
<pre><code>DIM cv AS CVAR = &quot;Test string&quot;
DIM cws AS CWSTR = cv.ToStr
</code></pre>
<h1 id="tostringarray"><a name="ToStringArray"></a>ToStringArray</h1>
<p>Extracts data from a vector structure into a PWSTR array.</p>
<pre><code>FUNCTION ToStringArray (BYVAL prgsz AS PWSTR, BYVAL crgsz AS ULONG) AS ULONG
</code></pre>
<table>
<thead>
<tr class="header">
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><em>prgsz</em></td>
<td>Pointer to a buffer that contains <em>crgn</em> PWSTR values. When this function returns, the buffer has been initialized with elements extracted from the source VARIANT structure.</td>
</tr>
<tr class="even">
<td><em>crgsz</em></td>
<td>The number of elements in the buffer pointed to by <em>prgsz</em>.</td>
</tr>
</tbody>
</table>
<h4 id="return-value-70">Return value</h4>
<p>The count of PWSTR elements extracted from the CVAR.</p>
<h4 id="remarks-38">Remarks</h4>
<p>This helper function is used when the calling application expects a CVAR to hold an array of PWSTR values. If the VARIANT contains more elements than will fit into the <em>prgsz</em> buffer, this function returns 0.</p>
<h1 id="tostringarrayalloc"><a name="ToStringArrayAlloc"></a>ToStringArrayAlloc</h1>
<p>Extracts an array of PWSTR values from CVAR.</p>
<pre><code>FUNCTION ToStringArrayAlloc (BYVAL pprgsz AS PWSTR PTR) AS ULONG
</code></pre>
<table>
<thead>
<tr class="header">
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><em>pprgsz</em></td>
<td>Pointer to a PWSTR PTR variable that will recive a pointer to an array of PWSTR values extracted from the source CVAR.</td>
</tr>
</tbody>
</table>
<h4 id="return-value-71">Return value</h4>
<p>The count of PWSTR elements extracted from the CVAR.</p>
<h4 id="remarks-39">Remarks</h4>
<p>This helper function is used when the calling application expects a CVAR to hold an array of PWSTR values.</p>
<p>This function extracts an array of PWSTR values into a newly allocated array. The calling application is responsible for using <strong>CoTaskMemFree</strong> to free the memory used by each of the strings and to release the array pointed to by pprgn when it is no longer needed.</p>
<h1 id="tostrret"><a name="ToStrRet"></a>ToStrRet</h1>
<p>Returns the contents of a CVAR of type VT_BSTR to a STRRET stucture.</p>
<pre><code>FUNCTION ToStrRet () AS STRRET
</code></pre>
<h4 id="return-value-72">Return value</h4>
<p>A STRRET structure.</p>
<h1 id="tosystemtime"><a name="ToSystemTime"></a>ToSystemTime</h1>
<p>Returns the contents of CVAR of type VT_DATE as a FILETIME structure.</p>
<pre><code>FUNCTION ToSystemTime () AS SYSTEMTIME
</code></pre>
<h4 id="return-value-73">Return value</h4>
<p>A SYSTEMTIME structure.</p>
<h1 id="toulongarray"><a name="ToULongArray"></a>ToULongArray</h1>
<p>Extracts an array of ULONG values from CVAR.</p>
<pre><code>FUNCTION ToULongArray (BYVAL prgn AS ULONG PTR, BYVAL crgn AS ULONG) AS ULONG
</code></pre>
<table>
<thead>
<tr class="header">
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><em>prgn</em></td>
<td>Pointer to a buffer that contains <em>crgn</em> ULONG variables. When this function returns, the buffer has been initialized with UInt32 elements extracted from CVAR.</td>
</tr>
<tr class="even">
<td><em>crgn</em></td>
<td>The number of elements in the buffer pointed to by <em>prgn</em>.</td>
</tr>
</tbody>
</table>
<h4 id="return-value-74">Return value</h4>
<p>The count of UInt32 elements extracted from the CVAR.</p>
<h4 id="remarks-40">Remarks</h4>
<p>This helper function is used when the calling application expects a VARIANT to hold an array that consists of a fixed number of UInt32 values.</p>
<p>If the source VARIANT is of type VT_ARRAY OR VT_UI4, this function extracts up to <em>crgn</em> UInt32 values and places them into the buffer pointed to by <em>prgn</em>. If the VARIANT contains more elements than will fit into the <em>prgn</em> buffer, this function returns 0.</p>
<h1 id="toulongarrayalloc"><a name="ToULongArrayAlloc"></a>ToULongArrayAlloc</h1>
<p>Extracts an array of ULONG values from CVAR.</p>
<pre><code>FUNCTION ToULongArrayAlloc (BYVAL pprgn AS ULONG PTR PTR) AS ULONG
</code></pre>
<table>
<thead>
<tr class="header">
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><em>pprgn</em></td>
<td>Pointer to a ULONG PTR variable that will recive a pointer to an array of ULONG values extracted from the source CVAR.</td>
</tr>
</tbody>
</table>
<h4 id="return-value-75">Return value</h4>
<p>The count of ULONG elements extracted from the CVAR.</p>
<h4 id="remarks-41">Remarks</h4>
<p>This helper function is used when the calling application expects a CVAR to hold an array of ULONG values.</p>
<p>If CVAR is of type VT_ARRAY OR VT_UI4, this function extracts an array of ULONG values into a newly allocated array. The calling application is responsible for using <strong>CoTaskMemFree</strong> to release the array pointed to by <em>pprgn</em> when it is no longer needed.</p>
<h1 id="toulongintarray"><a name="ToULongIntArray"></a>ToULongIntArray</h1>
<p>Extracts an array of ULONGINT values from CVAR.</p>
<pre><code>FUNCTION ToULongIntArray (BYVAL prgn AS ULONGINT PTR, BYVAL crgn AS ULONG) AS ULONG
</code></pre>
<table>
<thead>
<tr class="header">
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><em>prgn</em></td>
<td>Pointer to a buffer that contains <em>crgn</em> ULONGINT variables. When this function returns, the buffer has been initialized with UInt64 elements extracted from CVAR.</td>
</tr>
<tr class="even">
<td><em>crgn</em></td>
<td>The number of elements in the buffer pointed to by <em>prgn</em>.</td>
</tr>
</tbody>
</table>
<h4 id="return-value-76">Return value</h4>
<p>The count of UInt64 elements extracted from the CVAR.</p>
<h4 id="remarks-42">Remarks</h4>
<p>This helper function is used when the calling application expects a VARIANT to hold an array that consists of a fixed number of UInt64 values.</p>
<p>If the source VARIANT is of type VT_ARRAY OR VT_UI8, this function extracts up to <em>crgn</em> UInt64 values and places them into the buffer pointed to by <em>prgn</em>. If the VARIANT contains more elements than will fit into the <em>prgn</em> buffer, this function returns 0.</p>
<h1 id="toulongintarrayalloc"><a name="ToULongIntArrayAlloc"></a>ToULongIntArrayAlloc</h1>
<p>Extracts an array of ULONGINT values from CVAR.</p>
<pre><code>FUNCTION ToULongIntArrayAlloc (BYVAL pprgn AS ULONGINT PTR PTR) AS ULONG
</code></pre>
<table>
<thead>
<tr class="header">
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><em>pprgn</em></td>
<td>Pointer to a ULONGINT PTR variable that will recive a pointer to an array of ULONGINT values extracted from the source CVAR.</td>
</tr>
</tbody>
</table>
<h4 id="return-value-77">Return value</h4>
<p>The count of ULONGINT elements extracted from the CVAR.</p>
<h4 id="remarks-43">Remarks</h4>
<p>This helper function is used when the calling application expects a CVAR to hold an array of ULONGINT values.</p>
<p>If CVAR is of type VT_ARRAY OR VT_UI8, this function extracts an array of ULONGINT values into a newly allocated array. The calling application is responsible for using <strong>CoTaskMemFree</strong> to release the array pointed to by <em>pprgn</em> when it is no longer needed.</p>
<h1 id="toushortarray"><a name="ToUShortArray"></a>ToUShortArray</h1>
<p>Extracts an array of UInt16 values from CVAR.</p>
<pre><code>FUNCTION ToUShortArray (BYVAL prgn AS USHORT PTR, BYVAL crgn AS ULONG) AS ULONG
</code></pre>
<table>
<thead>
<tr class="header">
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><em>prgn</em></td>
<td>Pointer to a buffer that contains <em>crgn</em> UInt16 variables. When this function returns, the buffer has been initialized with UInt16 elements extracted from CVAR.</td>
</tr>
<tr class="even">
<td><em>crgn</em></td>
<td>The number of elements in the buffer pointed to by <em>prgn</em>.</td>
</tr>
</tbody>
</table>
<h4 id="return-value-78">Return value</h4>
<p>The count of UInt16 elements extracted from the CVAR.</p>
<h4 id="remarks-44">Remarks</h4>
<p>This helper function is used when the calling application expects a VARIANT to hold an array that consists of a fixed number of UInt16 values.</p>
<p>If the source VARIANT is of type VT_ARRAY OR VT_I2, this function extracts up to <em>crgn</em> UInt16 values and places them into the buffer pointed to by <em>prgn</em>. If the VARIANT contains more elements than will fit into the <em>prgn</em> buffer, this function returns 0.</p>
<h1 id="toushortarrayalloc"><a name="ToUShortArrayAlloc"></a>ToUShortArrayAlloc</h1>
<p>Extracts an array of USHORT values from CVAR.</p>
<pre><code>FUNCTION ToUShortArrayAlloc (BYVAL pprgn AS USHORT PTR PTR) AS ULONG
</code></pre>
<table>
<thead>
<tr class="header">
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><em>pprgn</em></td>
<td>Pointer to a USHORT PTR variable that will recive a pointer to an array of USHORT values extracted from the source CVAR.</td>
</tr>
</tbody>
</table>
<h4 id="return-value-79">Return value</h4>
<p>The count of USHORT elements extracted from the CVAR.</p>
<h4 id="remarks-45">Remarks</h4>
<p>This helper function is used when the calling application expects a CVAR to hold an array of USHORT values.</p>
<p>If CVAR is of type VT_ARRAY OR VT_UI2, this function extracts an array of SHORT values into a newly allocated array. The calling application is responsible for using <strong>CoTaskMemFree</strong> to release the array pointed to by <em>pprgn</em> when it is no longer needed.</p>
<h1 id="toutf8"><a name="ToUtf8"></a>ToUtf8</h1>
<p>Returns the contents of a CVAR containing a BSTR as an UTF-8 encoded string.</p>
<pre><code>FUNCTION ToUtf8 () AS STRING
</code></pre>
<h4 id="return-value-80">Return value</h4>
<p>The UTF-8 string.</p>
<h1 id="tovbdate"><a name="ToVbDate"></a>ToVbDate</h1>
<p>Returns the contents of a CVAR of type VT_DATE as a DATE value.</p>
<pre><code>FUNCTION ToVbDate () AS DATE_
</code></pre>
<h4 id="return-value-81">Return value</h4>
<p>A DATE_ value (double).</p>
<h1 id="towstr"><a name="ToWStr"></a>ToWStr</h1>
<p>Extracts the content of the underlying variant and returns it as a CWSTR.</p>
<pre><code>FUNCTION ToWStr () AS CWSTR
</code></pre>
<h4 id="return-value-82">Return value</h4>
<p>The contents of the variant as a CWSTR.</p>
<h4 id="example-2">Example</h4>
<pre><code>DIM cv AS CVAR = &quot;Test string&quot;
DIM cws AS CWSTR = cv.ToWStr
</code></pre>
<h1 id="valdouble"><a name="ValDouble"></a>ValDouble</h1>
<p>Converts the variant to a floating point number (DOUBLE)</p>
<pre><code>FUNCTION ValDouble () AS DOUBLE
</code></pre>
<h1 id="valint"><a name="ValInt"></a>ValInt</h1>
<p>Converts the variant to a signed 32-bit integer (LONG).</p>
<pre><code>FUNCTION ValInt () AS LONG
</code></pre>
<h1 id="vallong"><a name="ValLong"></a>ValLong</h1>
<p>Converts the variant to a signed 32-bit integer (LONG).</p>
<pre><code>FUNCTION ValLong () AS LONG
</code></pre>
<h1 id="vallongint"><a name="ValLongInt"></a>ValLongInt</h1>
<p>Converts the variant to a signed 64-bit integer (LONGINT).</p>
<pre><code>FUNCTION ValLongInt () AS LONGINT
</code></pre>
<h1 id="value"><a name="Value"></a>Value</h1>
<p>Converts the variant to a floating point number (DOUBLE).</p>
<pre><code>FUNCTION Value () AS DOUBLE
</code></pre>
<h1 id="valuint"><a name="ValUInt"></a>ValUInt</h1>
<p>Converts the variant to a 32.bit unsigned integer (ULONG).</p>
<pre><code>FUNCTION ValUInt () AS ULONG
</code></pre>
<h1 id="valulong"><a name="ValULong"></a>ValULong</h1>
<p>Converts the variant to a 32.bit unsigned integer (ULONG).</p>
<pre><code>FUNCTION ValULong () AS ULONG
</code></pre>
<h1 id="valulongint"><a name="ValULongInt"></a>ValULongInt</h1>
<p>Converts the variant to a 64-bit unsigned integer (ULONGINT).</p>
<pre><code>FUNCTION ValULongInt () AS ULONGINT
</code></pre>
<h1 id="afxcvartostr"><a name="AfxCVarToStr"></a>AfxCVarToStr</h1>
<p>Extracts the contents of a CVAR to a CWSTR.</p>
<pre><code>FUNCTION AfxCVarToStr OVERLOAD (BYREF cv AS CVAR) AS CWSTR
</code></pre>
<h1 id="afxcvartostr-1"><a name="AfxCVarToStr"></a>AfxCVarToStr</h1>
<p>Extracts the contents of a CVAR to a CWSTR.</p>
<pre><code>FUNCTION AfxCVarToStr OVERLOAD (BYVAL pcv AS CVAR PTR) AS CWSTR
</code></pre>
<h1 id="afxcvarianttobuffer"><a name="AfxCVariantToBuffer"></a>AfxCVariantToBuffer</h1>
<p>Extracts the contents of a variant that contains an array of bytes.</p>
<pre><code>FUNCTION AfxCVariantToBuffer (BYREF cvIn AS CVAR, BYVAL pv AS LPVOID, BYVAL cb AS ULONG) AS ULONG
</code></pre>
<table>
<thead>
<tr class="header">
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><em>pv</em></td>
<td>Pointer to a buffer of length <em>cb</em> bytes. When this function returns, contains the first <em>cb</em> bytes of the extracted buffer value.</td>
</tr>
<tr class="even">
<td><em>cb</em></td>
<td>The size of the <em>pv</em> buffer, in bytes. The buffer should be the same size as the data to be extracted, or smaller.</td>
</tr>
</tbody>
</table>
<h1 id="afxcvaroptprm"><a name="AfxCVarOptPrm"></a>AfxCVarOptPrm</h1>
<p>Returns a CVAR suitable to be used with optional parameters.</p>
<pre><code>FUNCTION AfxCVarOptPrm () AS CVAR
</code></pre>
<h4 id="remarks-46">Remarks</h4>
<p>If you want to call a method that has optional variant parameters, you still have to pass the parameters, but in a way That the methods knows that they were omitted. Specifically, you have to pass them as type VT_ERROR, code DISP_E_PARAM_NOT_FOUND.</p>
<pre><code>DIM v AS VARIANT = TYPE(VT_ERROR, 0, 0, 0, DISP_E_PARAMNOTFOUND)
</code></pre>
</body>
</html>

